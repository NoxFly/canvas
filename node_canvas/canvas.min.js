/**
 * @copyright   Copyright (C) 2019 - 2020 Dorian Thivolle All rights reserved.
 * @license     GNU General Public License version 3 or later; see LICENSE.txt
 * @author		Dorian Thivolle
 * @name		canvas
 * @package		NoxFly/canvas
 * @see			https://github.com/NoxFly/canvas
 * @since		30 Dec 2019
 * @version		{1.3.5}
 */
const NodeCanvas=require("canvas");module.exports.PI=Math.PI;const NOX_PV={colorTreatment:(...oColor)=>{let n=oColor.length;if(1==n&&"number"==typeof oColor[0]){if(0<=(oColor=oColor[0])&&oColor<=255)return`rgb(${oColor}, ${oColor}, ${oColor})`}else{if(2==n&&oColor.every((c,i)=>"number"==typeof c&&0<=c&&c<=255||4==i&&0<=c&&c<=1))return`rgba(${oColor[0]}, ${oColor[0]}, ${oColor[0]}, ${oColor[1]>1?oColor[1]/255:oColor[1]})`;if([3,4].includes(n)&&oColor.every(c=>"number"==typeof c)){if(oColor.every((c,i)=>0<=c&&c<=255||4==i&&0<=c&&c<=1))return`rgb${4==n?"a":""}(${oColor[0]}, ${oColor[1]}, ${oColor[2]}${4==n?`, ${oColor[3]>1?oColor[3]/255:oColor[3]}`:""})`}else if(1==n&&"string"==typeof oColor[0]){let color=(oColor=oColor[0]).replace(/\s/gi,""),reg={hex:/^#([0-9a-z]{3}){1,2}$/i,rgb:/^rgba?\((\d{1,3},){2}\d{1,3}(,\d(\.\d+)?)?\)$/,hsl:/^hsl\(\d{1,3},\d{1,3}%,\d{1,3}%\)$/,name:/^\w{3,30}$/};for(let regex in reg)if(reg[regex].test(color))return oColor}else if(oColor[0]instanceof HEX||oColor[0]instanceof RGB||oColor[0]instanceof HSL)return oColor[0].toString()}return canvas?window.getComputedStyle(canvas).backgroundColor:"#000"}};class Canvas{constructor(width,height,background=null){this._=new NodeCanvas.createCanvas(width,height),(()=>{this.background=background,this.sFontSize="12px",this.sFontFamily="Monospace",this.bFill=!0,this.bStroke=!0})(),this.toDataURL=()=>this._.toDataURL()}get width(){return this._.width}get height(){return this._.height}getContext(context){return void 0===this.ctx?(this.ctx=this._.getContext(context),null!==this.background&&(this.fill(this.background),this.fillRect(0,0,this.width,this.height))):console.error("This canvas already has a context."),this.ctx}toString(){return this._}moveTo(x,y){this.ctx.moveTo(x,y)}lineTo(x,y){this.ctx.lineTo(x,y)}line(x1,y1,x2,y2){this.ctx.beginPath(),this.ctx.moveTo(x1,y1),this.ctx.lineTo(x2,y2),this.bStroke&&this.ctx.stroke(),this.ctx.closePath()}polyline(...values){if(values.length%2==0){this.ctx.beginPath(),values.length>0&&this.ctx.moveTo(values[0],values[1]);for(let i=2;i<values.length;i+=2){let x=values[i],y=values[i+1];this.ctx.lineTo(x,y)}this.bStroke&&this.ctx.stroke(),this.bFill&&this.ctx.fill(),this.ctx.closePath()}else console.error("The function polyline must take an even number of values")}fillRect(x,y,width,height){this.ctx.fillRect(x,y,width,height),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}arc(x,y,r,start,end,antiClockwise=!1){this.ctx.beginPath(),this.ctx.arc(x,y,r,start,end,antiClockwise),this.bStroke&&this.ctx.stroke(),this.bFill&&this.ctx.fill(),this.ctx.closePath()}circle(x,y,r){this.arc(x,y,r,0,2*PI)}strokeRect(x,y,width,height){this.ctx.strokeRect(x,y,width,height),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}rect(x,y,width,height){this.ctx.rect(x,y,width,height),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}path(p){if(!(p=p.trim()).startsWith("M"))return;p=p.split(" ");let mode="M";const modes={M:{n:2,f:(x,y)=>this.moveTo(x,y)},L:{n:2,f:(x,y)=>this.lineTo(x,y)},H:{n:1,f:(x,y)=>this.lineTo(x,y)},V:{n:1,f:(y,x)=>this.lineTo(x,y)},A:{n:6,f:(x,y,r,start,end,antiClockwise)=>this.ctx.arc(x,y,r,radian(start),radian(end),1===antiClockwise)},Z:{n:0,f:()=>this.lineTo(parseFloat(p[1]),parseFloat(p[2]))}},reg=new RegExp(`^[${Object.keys(modes).join("")}]|(-?d+(.d+)?)$`,"i");if(0==p.filter(point=>reg.test(point)).length)return;if(p.length<3)return;let d=[];const lastIdx=p.length-1;for(let i=0;i<p.length;i++){let point=p[i];if(/[a-z]/i.test(point)){if(mode=point,"Z"==mode){if(i!=lastIdx)return;d.push("Z")}if(["z"].includes(mode))return;const nArg=modes[mode.toUpperCase()].n;if(lastIdx-nArg<i)return;let lastPos={x:0,y:0};if(d.length>0){let prev=d[d.length-1],hv=["H","V"].indexOf(prev[0]);if(-1!==hv)lastPos.x=prev[1+hv],lastPos.y=prev[2-hv];else{let k=1;lastPos.x=prev[k],lastPos.y=prev[k+1]}}let arr=[mode.toUpperCase()],hv=["H","V"].indexOf(arr[0]);for(let j=0;j<nArg;j++){i++;let n=parseFloat(p[i]);if(isNaN(n))return;arr.push(n)}if(-1!==hv&&arr.push(lastPos[Object.keys(lastPos)[1-hv]]),"A"==arr[0]&&(arr[1]-=arr[3]),/[mlhva]/.test(mode)&&("v"===mode?arr[1]+=lastPos.y:"h"===mode?arr[1]+=lastPos.x:(arr[1]+=lastPos.x,arr[2]+=lastPos.y)),d.push(arr),"A"==arr[0]){const angle=radian(arr[5]);let x=arr[1]+cos(angle)*arr[3];y=arr[2]+sin(angle)*arr[3],d.push(["M",x,y])}}}this.ctx.beginPath(),d.forEach(step=>{"string"==typeof step?modes[step].f():modes[step[0]].f(...step.slice(1))}),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke(),this.ctx.closePath()}text(txt,x=0,y=0){if(/\n/.test(txt)){let size=this.sFontSize.replace(/(\d+)(\w+)?/,"$1");txt=txt.split("\n");for(let i=0;i<txt.length;i++)this.ctx.fillText(txt[i],x,y+i*size)}else this.ctx.fillText(txt,x,y)}setFont(size,font){this.ctx.font=`${size}px ${font}`,this.sFontSize=`${size}px`,this.sFontFamily=font}fontSize(size){this.ctx.font=`${size}px ${this.sFontFamily}`,this.sFontSize=`${size}px`}fontFamily(font){ctx.font=`${this.sFontSize} ${font}`,sFontFamily=font}alignText(alignment){this.ctx.textAlign=["left","right","center","start","end"].indexOf(alignment)>-1?alignment:"left"}noFill(){this.bFill=!1}noStroke(){this.bStroke=!1}background(...color){this.background=NOX_PV.colorTreatment(...color)}stroke(...color){this.ctx.strokeStyle=NOX_PV.colorTreatment(...color),this.bStroke=!0}strokeWeight(weight){this.ctx.lineWidth=weight}linecap(style){this.ctx.lineCap=["butt","round","square"].indexOf(style)>-1?style:"butt"}fill(...color){this.ctx.fillStyle=NOX_PV.colorTreatment(...color),this.bFill=!0}clearRect(x,y,width,height){this.ctx.clearRect(x,y,x+width,y+height)}push(){this.ctx.save()}pop(){this.ctx.restore()}translate(x,y){this.ctx.translate(x,y)}rotate(degree){this.ctx.rotate(radian(degree))}clip(){this.ctx.clipPath()}}module.exports.createCanvas=(width,height,context="2d",background=null)=>{if(width<=0||height<=0)return console.warn("Canvas size must be higher than 0"),null;null!==background&&(background=NOX_PV.colorTreatment(background));const canvas=new Canvas(width,height,background),ctx=canvas.getContext(context);return canvas},module.exports.radian=deg=>deg*(PI/180),module.exports.degree=rad=>rad*(180/PI),module.exports.angleToVector=angle=>new Vector(cos(angle),sin(angle)),module.exports.vectorToAngle=vec=>{const baseVector=new Vector(1,0);return angleBetweenVectors(baseVector,vec)},module.exports.angleBetweenVectors=(a,b)=>{const ab=a.x*b.x+a.y*b.y+a.z*b.z,cosO=ab/(a.mag*b.mag),O=acos(cosO);return O},module.exports.dist=(a,b)=>Math.hypot(b.x-a.x,b.y-a.y,b.z-a.z),module.exports.map=(arrayOrValue,start1,end1,start2,end2)=>{const m=val=>(val-start1)*(end2-start2)/(end1-start1)+start2;return"number"==typeof arrayOrValue?m(arrayOrValue):arrayOrValue.map(val=>m(val))},module.exports.pow=(n,p=2)=>Math.pow(n,p),module.exports.abs=n=>n>=0?n:-n,module.exports.sqrt=n=>Math.sqrt(n),module.exports.min=(...values)=>Math.min(...values),module.exports.max=(...values)=>Math.max(...values),module.exports.round=n=>Math.round(n),module.exports.floor=n=>Math.floor(n),module.exports.ceil=n=>Math.ceil(n),module.exports.random=(iMin,iMax=0)=>floor(Math.random()*(max(iMin,iMax)-min(iMin,iMax)+1))+min(iMin,iMax),module.exports.sin=x=>Math.sin(x),module.exports.cos=x=>Math.cos(x),module.exports.tan=x=>Math.tan(x),module.exports.asin=x=>Math.asin(x),module.exports.acos=x=>Math.acos(x),module.exports.atan=x=>Math.atan(x),module.exports.atan2=(x,y)=>Math.atan2(y,x),module.exports.sinh=x=>Math.sinh(x),module.exports.cosh=x=>Math.cosh(x),module.exports.exp=x=>Math.exp(x),module.exports.log=x=>Math.log(x),module.exports.log10=x=>Math.log10(x),module.exports.sum=(...values)=>values.reduce((a,b)=>a+b),module.exports.mean=(...values)=>sum(...values)/values.length,module.exports.median=(...values)=>{if(0===values.length)return 0;values.sort((a,b)=>a-b);let half=floor(values.length/2);return values.length%2?values[half]:(values[half-1]+values[half])/2},module.exports.mode=(...values)=>values.reduce((a,b,i,arr)=>arr.filter(v=>v===a).length>=arr.filter(v=>v===b).length?a:b,null),module.exports.variance=(...values)=>values.reduce((a,b)=>a+pow(b-mean(...values)),0),module.exports.std=(...values)=>sqrt(variance(...values)),module.exports.RGB=class{constructor(r,g=null,b=null,a=255){this.color={r:0,g:0,b:0},void 0===r&&(r=0),null!==g&&null===b&&(a=g,g=b=r),null===g&&(g=r,b=r),this.r=r,this.g=g,this.b=b,this.a=a}valueInInterval(val){return val<0||val>255?(console.error(`Color interval [0 - 255] no repespected (${val} given)`),min(max(val,0),255)):val}get r(){return this.color.r}get g(){return this.color.g}get b(){return this.color.b}get a(){return this.color.a}set r(val){this.color.r=this.valueInInterval(val)}set g(val){this.color.g=this.valueInInterval(val)}set b(val){this.color.b=this.valueInInterval(val)}set a(val){this.color.a=this.valueInInterval(val)}set(r,g,b,a=null){this.r=r,this.g=g,this.b=b,a&&(this.a=a)}toString(){return`rgb${255!=this.a?"a":""}(${this.r}, ${this.g}, ${this.b}${255!=this.a?`, ${round(this.a/255*10)/10}`:""})`}intVal(){return[this.r,this.g,this.b,this.a]}toHEX(){let r=Number(this.r).toString(16);r.length<2&&(r="0"+r);let g=Number(this.g).toString(16);g.length<2&&(g="0"+g);let b=Number(this.b).toString(16);b.length<2&&(b="0"+b);const rgb="#"+r+g+b;return new HEX(rgb)}toHSL(){const r=this.r/255,g=this.g/255,b=this.b/255,imax=max(r,g,b),imin=min(r,g,b);let h,s,l=(imax+imin)/2;if(imax==imin)h=s=0;else{let d=imax-imin;switch(s=l>.5?d/(2-imax-imin):d/(imax+imin),imax){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return new HSL(round(10*h)/10,round(10*s)/10,round(10*l)/10)}},module.exports.HEX=class{constructor(hexaColor){this.color={int:0,str:"#000000"},this.set(hexaColor)}toString(){return this.color.str}intVal(){return this.color.int}set(hexaColor){if("number"==typeof hexaColor){this.color.int=hexaColor;let h=hexaColor.toString(16)+"";this.color.str="#"+(4==h.length?"00":"")+h}else"string"==typeof hexaColor&&/^#?([0-9a-f]{3}){1,2}$/i.test(hexaColor)?(3==(hexaColor=hexaColor.replace("#","")).length&&(hexaColor=hexaColor[0].repeat(2)+hexaColor[1].repeat(2)+hexaColor[2].repeat(2)),this.color.str="#"+hexaColor,this.color.int=parseInt(hexaColor,16)):console.error(`Given parameter isn't a recognized hexadecimal number: ${hexaColor}`)}toRGB(){const r=(16711680&this.intVal())>>>16,g=(65280&this.intVal())>>>8,b=255&this.intVal();return new RGB(r,g,b)}toHSL(){return this.toRGB().toHSL()}},module.exports.HSL=class{constructor(hue,saturation=.5,light=.5){this.color={h:0,s:0,l:0},"number"!=typeof hue&&(console.error(`Hue given parameter isn't a recognized number value: ${hue}`),hue=0),this.h=hue,this.s=saturation,this.l=light}get h(){return this.color.h}get s(){return this.color.s}get l(){return this.color.l}set h(hue){this.color.h=hue>=0?hue%360:360-abs(hue)%360}set s(saturation){this.color.s=min(max(saturation,0),1)}set l(light){this.color.l=min(max(light,0),1)}add(hueToAdd){this.h=this.h+hueToAdd}sub(hueToSub){this.h=this.h-hueToSub}lighten(lightToAdd){this.l=this.l+lightToAdd}obscure(lightToSub){this.l=this.l-lightToSub}addSat(saturationToAdd){this.s=this.s+saturationToAdd}subSat(saturationToSub){this.s=this.s-saturationToSub}toString(){return`hsl(${this.h}, ${100*this.s}%, ${100*this.l}%)`}intVal(){return this.toHEX().intVal()}toHEX(){return this.toRGB().toHEX()}toRGB(){const C=(1-abs(2*this.l-1))*this.s,hh=this.h/60,X=C*(1-abs(hh%2-1));let r,g,b;r=g=b=0,hh>=0&&hh<1?[r,g]=[C,X]:hh>=1&&hh<2?[r,g]=[X,C]:hh>=2&&hh<3?[g,b]=[C,X]:hh>=3&&hh<4?[g,b]=[X,C]:[r,b]=hh>=4&&hh<5?[X,C]:[C,X];const m=this.l-C/2;return r=round(255*(r+m)),g=round(255*(g+m)),b=round(255*(b+m)),new RGB(r,g,b)}},module.exports.Vector=class{constructor(x,y=null,z=null){let dimension=1;this.coords={x:0,y:0,z:0},x instanceof Vector?(dimension=x.dimension,this.coords.x=x.x,2==dimension&&(this.coords.y=x.y),3==dimension&&(this.coords.z=x.z)):(this.coords.x=x,null!==y?(this.coords.y=y,dimension++):this.coords.y=0,null!==z?(this.coords.z=z,dimension++):this.coords.z=0),this.constants=Object.freeze({dimension:dimension})}get dimension(){return this.constants.dimension}get x(){return this.coords.x}get y(){return this.coords.y}get z(){return this.coords.z}set x(x){this.coords.x=x}set y(y){this.dimension>1?this.coords.y=y:console.error("Cannot modify the Y of a 1D vector")}set z(z){this.dimension>2?this.coords.z=z:console.error(`Cannot modify the Y of a ${this.dimension}D vector`)}normalize(apply=!1){let norm=Math.sqrt(pow(this.x)+pow(this.y)+pow(this.z)),me=new Vector(this);return 0!=norm&&(apply&&(this.x=this.x/norm,this.dimension>1&&(this.y=this.y/norm),this.dimension>2&&(this.z=this.z/norm)),me.x=me.x/norm,me.dimension>1&&(me.y=me.y/norm),me.dimension>2&&(me.z=me.z/norm)),me}set(x,y=0,z=0){return this.x=x,this.dimension>1&&(this.y=y),this.dimension>2&&(this.z=z),this}add(vec){return vec instanceof Vector?(this.x+=vec.x,this.dimension>1&&vec.dimension>1&&(this.y+=vec.y),this.dimension>2&&vec.dimension>2&&(this.z+=vec.z)):"number"==typeof vec?1==arguments.length?(this.x+=vec,this.dimension>1&&(this.y+=vec),this.dimension>2&&(this.z+=vec)):2==arguments.length&&2==this.dimension?(this.x+=vec,this.y+=arguments[1]):3==arguments.length&&3==this.dimension?(this.x+=vec,this.y+=arguments[1],this.z+=arguments[2]):console.error(`Wrong number of argument compared to the vector's dimension (${this.dimension})`):console.error("Argument type not accepted"),this}mult(vec){return vec instanceof Vector?(this.x*=vec.x,this.dimension>1&&vec.dimension>1&&(this.y*=vec.y),this.dimension>2&&vec.dimension>2&&(this.z*=vec.z)):"number"==typeof vec?1==arguments.length?(this.x*=vec,this.dimension>1&&(this.y*=vec),this.dimension>2&&(this.z*=vec)):2==arguments.length&&2==this.dimension?(this.x*=vec,this.y*=arguments[1]):3==arguments.length&&3==this.dimension?(this.x*=vec,this.y*=arguments[1],this.z*=arguments[2]):console.error(`Wrong number of argument compared to the vector's dimension (${this.dimension})`):console.error("Argument type not accepted"),this}div(vec){return vec instanceof Vector?(this.x/=vec.x,this.dimension>1&&vec.dimension>1&&(this.y/=vec.y),this.dimension>2&&vec.dimension>2&&(this.z/=vec.z)):"number"==typeof vec?1==arguments.length?(this.x/=vec,this.dimension>1&&(this.y/=vec),this.dimension>2&&(this.z/=vec)):2==arguments.length&&2==this.dimension?(this.x/=vec,this.y/=arguments[1]):3==arguments.length&&3==this.dimension?(this.x/=vec,this.y/=arguments[1],this.z/=arguments[2]):console.error(`Wrong number of argument compared to the vector's dimension (${this.dimension})`):console.error("Argument type not accepted"),this}invert(antiClockwise=!1){return this.dimension>1&&(2==this.dimension?[this.x,this.y]=[this.y,this.x]:[this.x,this.y,this.z]=antiClockwise?[this.y,this.z,this.x]:[this.z,this.x,this.y]),this}get mag(){return Math.hypot(this.x,this.y,this.z)}setMag(newMag){return this.x=this.x*newMag/this.mag,this.dimension>1&&(this.y=this.y*newMag/this.mag),this.dimension>2&&(this.z=this.z*newMag/this.mag),this}toString(){return`{x: ${this.x}${this.dimension>1?`, y: ${this.y}`:""}${this.dimension>2?`, z: ${this.z}`:""}}`}array(){let arr=[this.x];return this.dimension>1&&arr.push(this.y),this.dimension>2&&arr.push(this.z),arr}},module.exports.Path=class{constructor(x=null,y=null){this.d=null,this.isClosed=!1,x&&y&&this.MoveTo(x,y)}clear(){this.d=null}toString(){return this.d+(this.isClosed?" Z":"")}MoveTo(x,y){null===this.d?this.d=`M ${x} ${y}`:this.d+=` M ${x} ${y}`}moveTo(x,y){if(null===this.d)return console.error("You have to initialize the fist path's position");this.d+=` m ${x} ${y}`}LineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` L ${x} ${y}`}lineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` l ${x} ${y}`}Horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` H ${x}`}horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` h ${x}`}Vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` V ${y}`}vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` v ${y}`}Arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` A ${x} ${y} ${r} ${start} ${end} ${1==antiClockwise?1:0}`}arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` a ${x} ${y} ${r} ${start} ${end} ${1==antiClockwise?1:0}`}close(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!0}open(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!1}move(x,y=null){null===y&&x instanceof Vector&&([x,y]=[x.x,x.y]),null!==this.d&&(this.d=this.d.replace(/([MLHVA])\s([\d\.]+)(\s([\d\.]+))?/g,(c,p1,p2,p3)=>"H"==p1?`${p1} ${parseFloat(p2)+x}`:"V"==p1?`${p1} ${parseFloat(p2)+y}`:`${p1} ${parseFloat(p2)+x} ${parseFloat(p3)+y}`))}};