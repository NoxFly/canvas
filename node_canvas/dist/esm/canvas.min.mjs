/**
 * @copyright   Copyright (C) 2019 - 2023 Dorian Thivolle All rights reserved.
 * @license     GNU General Public License version 3 or later; see LICENSE.txt
 * @author		Dorian Thivolle
 * @name		canvas
 * @package		NoxFly/canvas
 * @see			https://github.com/NoxFly/canvas
 * @since		30 Dec 2019
 * @version		{1.6.6}
 */
import*as CVS from"canvas";const PI=Math.PI,colorTreatment=(...oColor)=>{const n=oColor.length,color0=oColor[0];if(color0 instanceof CanvasGradient||color0 instanceof CanvasPattern)return color0;if(color0 instanceof HEX||color0 instanceof RGB||color0 instanceof HSL)return color0.toString();if(n>0&&n<5&&oColor.every(c=>"number"==typeof c)){let p="rgb",g=0,b=0,a=0;3!==n&&4!==n||(g=1,b=2),2!==n&&4!==n||(p+="a",a=n-1);let color=`${p}(${color0}, ${oColor[g]}, ${oColor[b]}`;return a>0&&(color+=`, ${oColor[a]}`),color+=")",color}if(1===n&&"string"==typeof color0){oColor=color0.replace(/\s/gi,"");const reg={hex:/^#([0-9a-z]{3}){1,2}$/i,rgb:/^rgba?\((\d{1,3},){2}\d{1,3}(,(0|1|(0?\.\d+)))?\)$/,hsl:/^hsl\(\d{1,3},\d{1,3}%,\d{1,3}%\)$/,hsla:/^hsla\(\d{1,3},\d{1,3}%,\d{1,3}%,(0|1|(0?.\d+))\)$/,name:/^\w{3,30}$/};for(const regex in reg)if(reg[regex].test(oColor))return oColor}return"#000"},_perlin={lod:10,unit:1,gradient:[],seed:[],generateSeed:()=>Array(255).fill(0).map((i,j)=>j).sort(()=>Math.random()-.5),get:(x,y,lod=_perlin.lod,seed=_perlin.seed)=>{x/=lod,y/=lod;const[x0,y0]=[floor(x),floor(y)],[dx,dy,ii,jj]=[x-x0,y-y0,255&x0,255&y0],stuv=[];for(let i=0;i<4;i++)try{const v=seed[(ii+i%2+seed[jj+floor(i/2)])%255]%_perlin.gradient.length;stuv.push(_perlin.gradient[v][0]*(dx-i%2)+_perlin.gradient[v][1]*(dy-floor(i/2)))}catch(e){stuv.push(0)}const[Cx,Cy]=[3*dx*dx-2*dx*dx*dx,3*dy*dy-2*dy*dy*dy],[Li1,Li2]=[stuv[0]+Cx*(stuv[1]-stuv[0]),stuv[2]+Cx*(stuv[3]-stuv[2])];return map(Li1+Cy*(Li2-Li1),-_perlin.unit,_perlin.unit,0,1)}};_perlin.gradient=[[_perlin.unit,_perlin.unit],[-_perlin.unit,_perlin.unit],[_perlin.unit,-_perlin.unit],[-_perlin.unit,-_perlin.unit]];class Canvas{constructor(width,height,background=null,support=null){null!==support&&["svg","pdf"].includes(support.toUpperCase())?this._=CVS.createCanvas(width,height,support.toUpperCase()):this._=CVS.createCanvas(width,height),this.background=background,this.sFontSize="12px",this.sFontFamily="Monospace",this.bFill=!0,this.bStroke=!0}get ctx(){return this._.ctx}get width(){return this._.width}get height(){return this._.height}toDataURL(){return this._.toDataURL()}toBuffer(){return this._.toBuffer()}drawImage(image,...args){[2,4,6].includes(args.length)||console.error("wrong number of argument passed"),this.ctx.drawImage(image,...args)}toString(){return this._}beginPath(){ctx.beginPath()}closePath(){ctx.closePath()}moveTo(x,y){this.ctx.moveTo(x,y)}lineTo(x,y){this.ctx.lineTo(x,y)}line(x1,y1,x2,y2){this.beginPath(),this.ctx.moveTo(x1,y1),this.ctx.lineTo(x2,y2),this.closePath(),this.bStroke&&this.ctx.stroke()}polyline(...values){if(values.length%2==0){this.beginPath(),values.length>0&&this.ctx.moveTo(values[0],values[1]);for(let i=2;i<values.length;i+=2){let x=values[i],y=values[i+1];this.ctx.lineTo(x,y)}this.closePath(),this.bStroke&&this.ctx.stroke(),this.bFill&&this.ctx.fill()}else console.error("The function polyline must take an even number of values")}fillRect(x,y,width,height){this.ctx.fillRect(x,y,width,height),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}arc(x,y,r,start,end,antiClockwise=!1){this.beginPath(),this.ctx.arc(x,y,r,start,end,antiClockwise),this.bStroke&&this.ctx.stroke(),this.bFill&&this.ctx.fill(),this.closePath()}circle(x,y,r){this.arc(x,y,r,0,2*Math.PI)}strokeRect(x,y,width,height){this.ctx.strokeRect(x,y,width,height),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}rect(x,y,width,height){this.ctx.rect(x,y,width,height),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}roundRect(x=0,y=0,w=0,h=0,radius=0,radiusTR,radiusBR,radiusBL){void 0===radiusTR&&(radiusTR=radius),void 0===radiusBR&&(radiusBR=radius),void 0===radiusBL&&(radiusBL=radius);const x1=x+(radius=min(max(0,radius),50)),y1=y,x2=x+w-(radiusTR=min(max(0,radiusTR),50)),y2=y,x3=x+w,y3=y+h-(radiusBR=min(max(0,radiusBR),50)),x4=x+(radiusBL=min(max(0,radiusBL),50)),y4=y+h,x5=x,y5=y+radius;this.beginPath(),this.moveTo(x1,y1),this.lineTo(x2,y2),this.arcTo(x2+radiusTR,y2,x2+radiusTR,y2+radiusTR,radiusTR),this.lineTo(x3,y3),this.arcTo(x3,y3+radiusBR,x3-radiusBR,y3+radiusBR,radiusBR),this.lineTo(x4,y4),this.arcTo(x4-radiusBL,y4,x,y4-radiusBL,radiusBL),this.lineTo(x5,y5),this.arcTo(x5,y5-radius,x1,y1,radius),this.closePath(),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}path(p){if(!(p=p.trim()).startsWith("M"))return;p=p.split(" ");let mode="M";const modes={M:{n:2,f:(x,y)=>this.moveTo(x,y)},L:{n:2,f:(x,y)=>this.lineTo(x,y)},H:{n:1,f:(x,y)=>this.lineTo(x,y)},V:{n:1,f:(y,x)=>this.lineTo(x,y)},A:{n:6,f:(x,y,r,start,end,antiClockwise)=>this.ctx.arc(x,y,r,radian(start),radian(end),1===antiClockwise)},Z:{n:0,f:()=>this.lineTo(parseFloat(p[1]),parseFloat(p[2]))}},reg=new RegExp(`^[${Object.keys(modes).join("")}]|(-?d+(.d+)?)$`,"i");if(0==p.filter(point=>reg.test(point)).length)return;if(p.length<3)return;const d=[],lastIdx=p.length-1;for(let i=0;i<p.length;i++){let point=p[i];if(/[a-z]/i.test(point)){if(mode=point,"Z"===mode){if(i!==lastIdx)return;d.push("Z")}if(["z"].includes(mode))return;const nArg=modes[mode.toUpperCase()].n;if(lastIdx-nArg<i)return;let lastPos={x:0,y:0};if(d.length>0){let prev=d[d.length-1],hv=["H","V"].indexOf(prev[0]);if(-1!==hv)lastPos.x=prev[1+hv],lastPos.y=prev[2-hv];else{let k=1;lastPos.x=prev[k],lastPos.y=prev[k+1]}}let arr=[mode.toUpperCase()],hv=["H","V"].indexOf(arr[0]);for(let j=0;j<nArg;j++){i++;let n=parseFloat(p[i]);if(isNaN(n))return;arr.push(n)}if(-1!==hv&&arr.push(lastPos[Object.keys(lastPos)[1-hv]]),"A"==arr[0]&&(arr[1]-=arr[3]),/[mlhva]/.test(mode)&&("v"===mode?arr[1]+=lastPos.y:"h"===mode?arr[1]+=lastPos.x:(arr[1]+=lastPos.x,arr[2]+=lastPos.y)),d.push(arr),"A"==arr[0]){const angle=radian(arr[5]);let x=arr[1]+cos(angle)*arr[3];y=arr[2]+sin(angle)*arr[3],d.push(["M",x,y])}}}this.beginPath(),d.forEach(step=>{"string"==typeof step?modes[step].f():modes[step[0]].f(...step.slice(1))}),this.bFill&&this.ctx.fill(),this.bStroke&&this.ctx.stroke()}text(txt,x=0,y=0){if(/\n/.test(txt)){const size=parseInt(this.sFontSize.replace(/(\d+)(\w+)?/,"$1"));txt=txt.split("\n");for(let i=0;i<txt.length;i++)this.ctx.fillText(txt[i],x,y+i*size)}else this.ctx.fillText(txt,x,y)}setFont(size,font){this.ctx.font=`${size}px ${font}`,this.sFontSize=`${size}px`,this.sFontFamily=font}fontSize(size){this.ctx.font=`${size}px ${this.sFontFamily}`,this.sFontSize=`${size}px`}fontFamily(font){ctx.font=`${this.sFontSize} ${font}`,sFontFamily=font}alignText(alignment){this.ctx.textAlign=["left","right","center","start","end"].indexOf(alignment)>-1?alignment:"left"}bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y){this.ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)}quadraticCurveTo(cpx,cpy,x,y){this.ctx.quadraticCurveTo(cpx,cpy,x,y)}setShadow(shadowColor,shadowBlur=0,shadowOffsetX=0,shadowOffsetY=0){this.ctx.shadowColor=colorTreatment(shadowColor),this.ctx.shadowBlur=shadowBlur,this.ctx.shadowOffsetX=shadowOffsetX,this.ctx.shadowOffsetY=shadowOffsetY}removeShadow(){this.ctx.shadowColor="rgba(0, 0, 0, 0)",this.ctx.shadowBlur=0,this.ctx.shadowOffsetX=0,this.ctx.shadowOffsetY=0}noFill(){this.bFill=!1}noStroke(){this.bStroke=!1}background(...color){this.background=colorTreatment(...color)}stroke(...color){this.ctx.strokeStyle=colorTreatment(...color),this.bStroke=!0}strokeWeight(weight){this.ctx.lineWidth=weight}linecap(style){this.ctx.lineCap=["butt","round","square"].indexOf(style)>-1?style:"butt"}fill(...color){this.ctx.fillStyle=colorTreatment(...color),this.bFill=!0}clearRect(x,y,width,height){this.ctx.clearRect(x,y,x+width,y+height)}push(){this.ctx.save()}pop(){this.ctx.restore()}translate(x,y){this.ctx.translate(x,y)}rotate(degree){this.ctx.rotate(radian(degree))}clip(...args){this.ctx.clip(...args)}scale(x,y){this.ctx.scale(x,y)}createLinearGradient(x1,y1,x2,y2){this.ctx.createLinearGradient(x1,y1,x2,y2)}makeLinearGradient(x1,y1,x2,y2,...params){if(params.length%2!=0)return console.error("you have to tell params by pair (offset, color). Odd number of arguments given.");const grad=this.createLinearGradient(x1,y1,x2,y2);for(let i=0;i<params.length;i+=2){const offset=params[i],color=colorTreatment(params[i+1]);grad.addColorStop(offset,color)}return grad}setLineDash(array){if(!Array.isArray(array))return console.error("Array type expected. Got "+typeof array);this.ctx.setLineDash(array)}getLineDash(){return this.ctx.getLineDash()}globalAlpha(globalAlpha){this.ctx.globalAlpha=globalAlpha}globalCompositeOperation(type){this.ctx.globalCompositeOperation=type}setSmoothingQuality(quality){this.ctx.imageSmoothingQuality=quality}getTransform(){return this.ctx.getTransform()}lineDashOffset(value=0){this.ctx.lineDashOffset=value}lineJoin(type){this.ctx.lineJoin=type}measureText(text){return this.ctx.measureText(text)}resetTransform(){this.ctx.resetTransform()}setTransform(...transform){this.ctx.setTransform(...transform)}createPattern(image,repetition="repeat"){this.ctx.createPattern(image,repetition)}createImageData(widthOrImageData,height=null){return this.ctx.createImageData(...arguments)}putImageData(imageData,dx,dy,dirtyX=null,dirtyY=null,dirtyWidth=null,dirtyHeight=null){null===dirtyX?this.ctx.putImageData(imageData,dx,dy):this.ctx.putImageData(imageData,dx,dy,dirtyX,dirtyY,dirtyWidth,dirtyHeight)}getImageData(sx,sy,sw,sh){this.ctx.getImageData(sx,sy,sw,sh)}drawImage(image,sx,sy,sWidth=null,sHeight=null,dx=null,dy=null,dWidth=null,dHeight=null){null===sWidth?this.ctx.drawImage(image,sx,sy):null===dx?this.ctx.drawImage(image,sx,sy,sWidth,sHeight):this.ctx.drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)}}class CanvasImageManager{images={};async load(name,url=null){return"string"==typeof url&&(name in this.images||(this.images[name]=await CVS.loadImage(url))),this.images[name]}}const createCanvas=(width,height,background=null,support=null)=>{if(width<=0||height<=0)return console.warn("Canvas size must be higher than 0"),null;null!==background&&(background=colorTreatment(background));const canvas=new Canvas(width,height,background,support);return canvas},createImageManager=()=>new CanvasImageManager,radian=deg=>deg*(PI/180),degree=rad=>rad*(180/PI),angleToVector=angle=>new Vector(cos(angle),sin(angle)),vectorToAngle=vec=>{const baseVector=new Vector(1,0);return angleBetweenVectors(baseVector,vec)},angleBetweenVectors=(a,b)=>{const ab=a.x*b.x+a.y*b.y+a.z*b.z,cosO=ab/(a.mag*b.mag),O=acos(cosO);return O},dist=(a,b)=>{const x=b.x-a.x,y=b.y-a.y,z=b.z-a.z;return sqrt(x*x+y*y+z*z)},mag=(a,b)=>new Vector(b.x-a.x,b.y-a.y),map=(arrayOrValue,start1,end1,start2,end2)=>{const m=val=>(val-start1)*(end2-start2)/(end1-start1)+start2;return"number"==typeof arrayOrValue?m(arrayOrValue):arrayOrValue.map(val=>m(val))},pow=(n,p=2)=>Math.pow(n,p),abs=n=>n>=0?n:-n,sqrt=n=>Math.sqrt(n),min=(...values)=>Math.min(...values),max=(...values)=>Math.max(...values),clamp=(a,b,c)=>max(a,min(b,c)),round=n=>Math.round(n),floor=n=>Math.floor(n),ceil=n=>Math.ceil(n),random=(iMin=null,iMax=0)=>null===iMin?Math.random():floor(random()*(max(iMin,iMax)-min(iMin,iMax)+1))+min(iMin,iMax),sin=x=>Math.sin(x),cos=x=>Math.cos(x),tan=x=>Math.tan(x),asin=x=>Math.asin(x),acos=x=>Math.acos(x),atan=x=>Math.atan(x),atan2=(x,y)=>Math.atan2(y,x),sinh=x=>Math.sinh(x),cosh=x=>Math.cosh(x),exp=x=>Math.exp(x),log=x=>Math.log(x),log10=x=>Math.log10(x),sum=(...values)=>values.reduce((a,b)=>a+b),mean=(...values)=>sum(...values)/values.length,median=(...values)=>{if(0===values.length)return 0;values.sort((a,b)=>a-b);let half=floor(values.length/2);return values.length%2?values[half]:(values[half-1]+values[half])/2},mode=(...values)=>values.reduce((a,b,i,arr)=>arr.filter(v=>v===a).length>=arr.filter(v=>v===b).length?a:b,null),variance=(...values)=>values.reduce((a,b)=>a+pow(b-mean(...values)),0),std=(...values)=>sqrt(variance(...values)),perlin=(x,y=0)=>(_perlin.seed&&0!==_perlin.seed.length||(_perlin.seed=_perlin.generateSeed()),_perlin.get(x,y)),noiseDetails=detailLevel=>{"number"==typeof detailLevel&&(_perlin.lod=detailLevel)};class PerlinNoise{static mapnumberTypes=["default","rgb","hsl"];static getMapNumberTypeIndex=typeStr=>PerlinNoise.mapnumberTypes.indexOf(typeStr);constructor(lod=10,x=0,y=0,w=width,h=height,mapnumber="default"){this.lod=lod,this.seed=_perlin.generateSeed(),this.start={x:x,y:y},this.size={width:w,height:h},this.array=[],this.numberMapStyle=PerlinNoise.getMapNumberTypeIndex(mapnumber),this.calculate()}setLOD(lod){const tmp=this.lod;this.lod=lod,tmp!==lod&&this.calculate()}regenerateSeed(){this.seed=_perlin.generateSeed(),this.calculate()}setMapNumber(mapnumber){if(mapnumber=PerlinNoise.getMapNumberTypeIndex(mapnumber),this.numberMapStyle===mapnumber)return;let Lmin=0,Lmax=_perlin.unit,Rmin=0,Rmax=_perlin.unit;this.numberMapStyle>0&&([Lmin,Lmax]=[0,1===this.numberMapStyle?255:360]),this.numberMapStyle=mapnumber,this.numberMapStyle>0&&([Rmin,Rmax]=[0,1===this.numberMapStyle?255:360]),this.array.forEach((row,i)=>{this.array[i]=map(this.array[i],Lmin,Lmax,Rmin,Rmax)})}calculate(){this.array=[];for(let y=this.start.y;y<this.start.y+this.size.height;y++){const row=[];for(let x=this.start.x;x<this.start.x+this.size.width;x++)row.push(_perlin.get(x,y,this.lod,this.seed));this.array.push(row)}this.numberMapStyle>0&&this.setMapNumber(PerlinNoise.mapnumberTypes[this.numberMapStyle])}}class RGB{constructor(r,g=null,b=null,a=255){this.color={r:0,g:0,b:0},void 0===r&&(r=0),null!==g&&null===b&&(a=g,g=b=r),null===g&&(g=r,b=r),this.r=r,this.g=g,this.b=b,this.a=a}valueInInterval(val){return val<0||val>255?(console.error(`Color interval [0 - 255] no repespected (${val} given)`),min(max(val,0),255)):val}get r(){return this.color.r}get g(){return this.color.g}get b(){return this.color.b}get a(){return this.color.a}set r(val){this.color.r=this.valueInInterval(val)}set g(val){this.color.g=this.valueInInterval(val)}set b(val){this.color.b=this.valueInInterval(val)}set a(val){this.color.a=this.valueInInterval(val)}set(r,g,b,a=null){this.r=r,this.g=g,this.b=b,a&&(this.a=a)}toString(){return`rgb${255!=this.a?"a":""}(${this.r}, ${this.g}, ${this.b}${255!=this.a?`, ${round(this.a/255*10)/10}`:""})`}intVal(){return[this.r,this.g,this.b,this.a]}toHEX(){let r=Number(this.r).toString(16);r.length<2&&(r="0"+r);let g=Number(this.g).toString(16);g.length<2&&(g="0"+g);let b=Number(this.b).toString(16);b.length<2&&(b="0"+b);const rgb="#"+r+g+b;return new HEX(rgb)}toHSL(){const r=this.r/255,g=this.g/255,b=this.b/255,imax=max(r,g,b),imin=min(r,g,b);let h,s,l=(imax+imin)/2;if(imax==imin)h=s=0;else{let d=imax-imin;switch(s=l>.5?d/(2-imax-imin):d/(imax+imin),imax){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return new HSL(round(10*h)/10,round(10*s)/10,round(10*l)/10)}}class HEX{constructor(hexaColor){this.color={int:0,str:"#000000"},this.set(hexaColor)}toString(){return this.color.str}intVal(){return this.color.int}set(hexaColor){if("number"==typeof hexaColor){this.color.int=hexaColor;let h=hexaColor.toString(16)+"";this.color.str="#"+(4==h.length?"00":"")+h}else"string"==typeof hexaColor&&/^#?([0-9a-f]{3}){1,2}$/i.test(hexaColor)?(3==(hexaColor=hexaColor.replace("#","")).length&&(hexaColor=hexaColor[0].repeat(2)+hexaColor[1].repeat(2)+hexaColor[2].repeat(2)),this.color.str="#"+hexaColor,this.color.int=parseInt(hexaColor,16)):console.error(`Given parameter isn't a recognized hexadecimal number: ${hexaColor}`)}toRGB(){const r=(16711680&this.intVal())>>>16,g=(65280&this.intVal())>>>8,b=255&this.intVal();return new RGB(r,g,b)}toHSL(){return this.toRGB().toHSL()}}class HSL{constructor(hue,saturation=.5,light=.5){this.color={h:0,s:0,l:0},"number"!=typeof hue&&(console.error(`Hue given parameter isn't a recognized number value: ${hue}`),hue=0),this.h=hue,this.s=saturation,this.l=light}get h(){return this.color.h}get s(){return this.color.s}get l(){return this.color.l}set h(hue){this.color.h=hue>=0?hue%360:360-abs(hue)%360}set s(saturation){this.color.s=min(max(saturation,0),1)}set l(light){this.color.l=min(max(light,0),1)}add(hueToAdd){this.h=this.h+hueToAdd}sub(hueToSub){this.h=this.h-hueToSub}lighten(lightToAdd){this.l=this.l+lightToAdd}obscure(lightToSub){this.l=this.l-lightToSub}addSat(saturationToAdd){this.s=this.s+saturationToAdd}subSat(saturationToSub){this.s=this.s-saturationToSub}toString(){return`hsl(${this.h}, ${100*this.s}%, ${100*this.l}%)`}intVal(){return this.toHEX().intVal()}toHEX(){return this.toRGB().toHEX()}toRGB(){const C=(1-abs(2*this.l-1))*this.s,hh=this.h/60,X=C*(1-abs(hh%2-1));let r,g,b;r=g=b=0,hh>=0&&hh<1?[r,g]=[C,X]:hh>=1&&hh<2?[r,g]=[X,C]:hh>=2&&hh<3?[g,b]=[C,X]:hh>=3&&hh<4?[g,b]=[X,C]:[r,b]=hh>=4&&hh<5?[X,C]:[C,X];const m=this.l-C/2;return r=round(255*(r+m)),g=round(255*(g+m)),b=round(255*(b+m)),new RGB(r,g,b)}}class Vector{constructor(x,y=null,z=null,w=null){let dimension=1;this.coords={x:0,y:0,z:0,w:0};const tmp={x:0,y:0,z:0,w:0};x instanceof Vector?(dimension=x.dimension,tmp.x=x.x,tmp.y=x.y,tmp.z=x.z,tmp.w=x.w):(dimension=Array.from(arguments).filter(a=>"number"==typeof a).length,tmp.x=x,tmp.y=y,tmp.z=z,tmp.w=w),this.constants=Object.freeze({dimension:dimension}),this.set(tmp.x,tmp.y,tmp.z,tmp.w)}get dimension(){return this.constants.dimension}get mag(){return Math.hypot(this.x,this.y,this.z,this.w)}get x(){return this.coords.x}get y(){return this.coords.y}get z(){return this.coords.z}get w(){return this.coords.w}set x(x){this.coords.x=x}set y(y){this.dimension>1?this.coords.y=y:console.error("Cannot modify the Y of a 1D vector")}set z(z){this.dimension>2?this.coords.z=z:console.error(`Cannot modify the Z of a ${this.dimension}D vector`)}set w(w){this.dimension>2?this.coords.w=w:console.error(`Cannot modify the W of a ${this.dimension}D vector`)}copy(){return new Vector(this)}normalize(apply=!1){const norm=Math.hypot(this.x,this.y,this.z,this.w);return apply?(0!==norm&&(this.x/=norm,this.dimension>1&&(this.y/=norm,3===this.dimension&&(this.z/=norm,4===this.dimension&&(this.w/=norm)))),this):new Vector(this).normalize(!0)}equals(x,y=null,z=null,w=null){let vector;if(vector=x instanceof Vector?x:new Vector(x,y,z,w),this.dimension!==vector.dimension)return!1;for(const coord in this.coords)if(this.coords[coord]!==vector.coords[coord])return!1;return!0}set(x,y=null,z=null,w=null){if(x instanceof Vector)this.x=x.x,2===this.dimension&&(this.y=x.y),3===this.dimension&&(this.z=x.z),4===this.dimension&&(this.w=x.w);else{if("number"!=typeof x)return console.error("[Error] Vector::set : x parameter must be a number or a Vector");if(this.dimension>1){if(null!==y&&"number"!=typeof y)return console.error("[Error] Vector::set : y parameter must be a number");if(null!==z&&this.dimension>2&&"number"!=typeof z)return console.error("[Error] Vector::set : z parameter must be a number");if(null!==w&&this.dimension>3&&"number"!=typeof w)return console.error("[Error] Vector::set : w parameter must be a number")}this.x=x,this.dimension>1&&(null!==y&&(this.y=y),this.dimension>2&&null!=z&&(this.z=z,this.dimension>3&&null!=w&&(this.w=w)))}return this}add(x,y=null,z=null,w=null){return x instanceof Vector?this.set(this.x+x.x,this.y+x.y,this.z+x.z,this.w+x.w):(null===y&&(y=x),null===z&&(z=x),null===w&&(w=x),this.set(this.x+x,this.y+y,this.z+z,this.w+w))}sub(x,y=null,z=null,w=null){return x instanceof Vector?this.set(this.x-x.x,this.y-x.y,this.z-x.z,this.w-x.w):(null===y&&(y=x),null===z&&(z=x),null===w&&(w=x),this.set(this.x-x,this.y-y,this.z-z,this.w-w))}mult(x,y=null,z=null,w=null){return x instanceof Vector?this.set(this.x*x.x,this.y*x.y,this.z*x.z,this.w*x.w):(null===y&&(y=x),null===z&&(z=x),null===w&&(w=x),this.set(this.x*x,this.y*y,this.z*z,this.w*w))}div(x,y=null,z=null,w=null){return x instanceof Vector?this.set(this.x/x.x,this.y/x.y,this.z/x.z,this.w/x.w):(null===y&&(y=x),null===z&&(z=x),null===w&&(w=x),this.set(this.x/x,this.y/y,this.z/z,this.w/w))}invert(antiClockwise=!1){return this.dimension>1&&(2===this.dimension?[this.x,this.y]=[this.y,this.x]:3===this.dimension?[this.x,this.y,this.z]=antiClockwise?[this.y,this.z,this.x]:[this.z,this.x,this.y]:4===this.dimension&&([this.x,this.y,this.z,this.w]=[this.w,this.x,this.y,this.z])),this}setMag(newMag){return this.x=this.x*newMag/this.mag,this.dimension>1&&(this.y=this.y*newMag/this.mag),this.dimension>2&&(this.z=this.z*newMag/this.mag),this.dimension>3&&(this.w=this.w*newMag/this.mag),this}dot(other){return Object.keys(this.coords).reduce((acc,key)=>acc+this.coords[key]*other.coords[key],0)}rotate(angle){const radians=angle*Math.PI/180,cosius=cos(radians),sinus=sin(radians);return this.x=this.x*cosius-this.y*sinus,this.dimension>1&&(this.y=this.x*sinus+this.y*cosius,this.dimension>2&&(this.z=this.z*sinus+this.z*cosius,this.dimension>3&&(this.w=this.w*sinus+this.w*cosius))),this}toString(){let str="{";return this.dimension>0&&(str+=` x: ${this.x}`),this.dimension>1&&(str+=`, y: ${this.y}`),this.dimension>2&&(str+=`, z: ${this.z}`),this.dimension>3&&(str+=`, w: ${this.w}`),str+" }"}array(){const arr=[this.x];return this.dimension>1&&arr.push(this.y),this.dimension>2&&arr.push(this.z),this.dimension>3&&arr.push(this.w),arr}object(){const o={x:this.x};return this.dimension>1&&(o.y=this.y,this.dimension>2&&(o.z=this.z),this.dimension>3&&(o.w=this.w)),o}bow(x,y,style={}){if(this.dimension>2)return;style.strokeWeight?strokeWeight(style.strokeWeight):strokeWeight(1),style.stroke?stroke(style.stroke):stroke("#fff");const rotation=degree(vectorToAngle(this));push(),translate(x,y),line(0,0,this.x,this.y),linecap("round"),push(),translate(this.x,this.y),push(),rotate(rotation+25),line(0,0,-min(this.mag/2.5,10),0),rotate(-50),line(0,0,-min(this.mag/2.5,10),0),pop(),pop(),pop()}}class Matrix{properties={array:[],width:0,height:0};constructor(...args){if(args.length>0)if(args[0]instanceof Matrix){this.properties.width=args[0].width,this.properties.height=args[0].height;for(let i=0;i<args[0].height;i++){const row=[];for(let j=0;j<args[0].width;j++)row.push(args[0].at(j,i));this.properties.array.push(row)}}else if("number"==typeof args[0]){let fill=0;const w=args[0];let h=w;args.length>1&&"number"==typeof args[1]&&(h=args[1],args.length>2&&"number"==typeof args[2]&&(fill=args[2]));for(let i=0;i<h;i++){const row=[];for(let j=0;j<w;j++)row.push(fill);this.properties.array.push(row)}this.properties.width=w,this.properties.height=h}else 1===args.length&&Array.isArray(args[0])&&args[0].every(a=>Array.isArray(a)&&a.length===args[0][0].length&&a.every(e=>"number"==typeof e))?(this.properties.array=args[0],args[0].length>0&&(this.properties.width=args[0][0].length),this.properties.height=args[0].length):args.every(a=>Array.isArray(a)&&a.length===args[0].length&&a.every(e=>"number"==typeof e))?(this.properties.array=args,this.properties.width=args[0].length,this.properties.height=args.length):console.error("[Error] Matrix constructor : Unrecognized parameters.");this.properties.size=Object.freeze({x:this.properties.width,y:this.properties.height}),delete this.properties.width,delete this.properties.height}get array(){return this.properties.array}get array1D(){return this.array.reduce((a,b)=>[...a,...b],[])}get width(){return this.properties.size.x}get height(){return this.properties.size.y}get dimension(){return this.properties.size}toString(uncluttered=!1){const sep=this.height>0?"\n":"",brackets_open=uncluttered?"":"[",brackets_close=uncluttered?"":"]",m=uncluttered?max(...this.array.map(a=>max(...a.map(e=>e.toString().length)))):0,_format=uncluttered?arr=>arr.map(e=>" ".repeat(6+m-2*e.toString().length)+e).join(" "):arr=>arr.join(", ");return brackets_open+sep+this.properties.array.map(a=>"\t"+brackets_open+_format(a)+brackets_close).join("\n")+sep+brackets_close}at(x,y){return"number"==typeof x&&"number"==typeof y&&x>-1&&y>-1&&x<this.width&&y<this.height?this.array[y][x]:null}set(x,y,value){null!==this.at(x,y)&&"number"==typeof value&&(this.array[y][x]=value)}equals(matrix){if(matrix.width!==this.width||matrix.height!==this.height)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++)if(matrix.at(j,i)!==this.at(j,i))return!1;return!0}get isSymmetrical(){for(let i=0;i<this.width;i++)for(let j=0;j<this.height;j++)if(this.at(i,j)!==this.at(j,i))return!1;return!0}get isSquare(){return this.width===this.height}get isIdentity(){return this.isSquare&&this.array.every((arr,i)=>arr.every((e,j)=>i===j&&1===e||i!==j&&0===e))}get isDiagonal(){return this.isSquare&&this.array.every((arr,i)=>arr.every((e,j)=>i===j&&0!==e||i!==j&&0===e))}get isTriangular(){const a=this.isLowerTri,b=this.isUpperTri;return a?!b:b}get isLowerTri(){if(!this.isSquare)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++){const e=this.at(j,i);if(j>=i&&0!==e)return!1}return!0}get isUpperTri(){if(!this.isSquare)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++){const e=this.at(j,i);if(j<=i&&0!==e)return!1}return!0}get diagonal(){return this.isSquare?this.array.map((arr,i)=>arr[i]):[]}get det(){if(!this.isSquare)return 0;if(this.isIdendity)return 1;if(this.isDiagonal||this.isTriangular){const diag=this.diagonal;return diag.reduce((acc,curr)=>acc*curr,1)}if(2===this.width)return this.at(0,0)*this.at(1,1)-this.at(1,0)*this.at(0,1);if(3===this.width){const[a,b,c,d,e,f,g,h,i]=this.array1D;return a*e*i+d*h*c+b*f*g-(g*e*c+d*b*i+a*h*f)}{const det=m=>1===m.length?m[0][0]:2===m.length?m[0][0]*m[1][1]-m[0][1]*m[1][0]:m[0].reduce((r,e,i)=>r+(-1)**(i+2)*e*det(m.slice(1).map(c=>c.filter((_,j)=>i!=j))),0);return det(this.array)}}add(matrix,onACopy=!1){if("op"in this||(this.op=(a,b)=>a+b),!(matrix instanceof Matrix)&&"number"!=typeof matrix)return console.error(`[Error] Matrix::add : Matrix expected, ${typeof matrix} given`),delete this.op,this;if(matrix instanceof Matrix&&(matrix.width!==this.width||matrix.height!==this.height))return console.error("[Error] Matrix::add : Cannot operate an addition between 2 matrices with different dimensions."),delete this.op,this;const result=onACopy?new Matrix(this):this,b=matrix instanceof Matrix;for(let i=0;i<result.height;i++)for(let j=0;j<result.width;j++)result.set(j,i,this.op(result.at(j,i),b?matrix.at(j,i):matrix));return delete this.op,result}sub(matrix,onACopy=!1){return this.op=(a,b)=>a-b,this.add(matrix,onACopy)}mult(matrixOrnumber,onACopy=!1){const m=matrixOrnumber;let result=onACopy?new Matrix(this):this;if("number"==typeof m)for(let i=0;i<result.height;i++)for(let j=0;j<result.width;j++)result.set(j,i,result.at(j,i)*m);else if(m instanceof Matrix)if(m.height!==this.width||m.width!==this.height)console.error("[Error] Matrix::mult : matrices must have same transposed size.");else{result=new Matrix(this.height);for(let i=0;i<this.height;i++)for(let j=0;j<this.height;j++){let s=0;for(let k=0;k<this.width;k++)s+=this.at(k,i)*m.at(j,k);result.set(j,i,s)}}else console.error(`[Error] Matrix::mult : Matrix or number expected, got ${typeof matrixOrnumber}`);return result}transpose(onACopy=!1){let copy=new Matrix(this),me=this;onACopy&&([copy,me]=[me,copy]),me.properties.size=Object.freeze({x:me.properties.size.y,y:me.properties.size.x}),me.properties.array=[];for(let i=0;i<copy.width;i++){const row=[];for(let j=0;j<copy.height;j++)row.push(0);me.properties.array.push(row)}for(let i=0;i<copy.height;i++)for(let j=0;j<copy.width;j++)me.set(i,j,copy.at(j,i));return me}getColumn(x){if(x<0||x>this.width)return[];const column=[];for(let i=0;i<this.height;i++)column.push(this.at(x,i));return column}getRow(y){return y<0||y>this.height?[]:this.properties.array[y]}setColumn(x,column){if(x<0||x>this.width)return console.error("[Error] Matrix::setColumn : wrong index given.");if(column.length!==this.height)return console.error("[Error] Matrix::setColumn : column must have the same length as the matrix's height.");for(let i=0;i<this.height;i++)this.set(x,i,column[i]);return this}setRow(y,row){return y<0||y>this.height?console.error("[Error] Matrix::setRow : wrong index given."):row.length!==this.height?console.error("[Error] Matrix::setRow : row must have the same length as the matrix's width."):(this.properties.array[y]=row,this)}}class Path{constructor(x=null,y=null){this.d=null,this.isClosed=!1,x&&y&&this.MoveTo(x,y)}clear(){this.d=null}draw(){null!==this.d?path(this.d+(this.isClosed?" Z":"")):console.error("Cannot draw it because you didn't make a path")}MoveTo(x,y){null===this.d?this.d=`M ${x} ${y}`:this.d+=` M ${x} ${y}`}moveTo(x,y){if(null===this.d)return console.error("You have to initialize the fist path's position");this.d+=` m ${x} ${y}`}LineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` L ${x} ${y}`}lineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` l ${x} ${y}`}Horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` H ${x}`}horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` h ${x}`}Vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` V ${y}`}vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` v ${y}`}Arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` A ${x} ${y} ${r} ${start} ${end} ${!0===antiClockwise?1:0}`}arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` a ${x} ${y} ${r} ${start} ${end} ${!0===antiClockwise?1:0}`}close(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!0}open(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!1}move(x,y=null){null===y&&x instanceof Vector&&([x,y]=[x.x,x.y]),null!==this.d&&(this.d=this.d.replace(/([MLHVA])\s([\d\.]+)(\s([\d\.]+))?/g,(c,p1,p2,p3)=>"H"===p1?`${p1} ${parseFloat(p2)+x}`:"V"===p1?`${p1} ${parseFloat(p2)+y}`:`${p1} ${parseFloat(p2)+x} ${parseFloat(p3)+y}`))}}class Quadtree{static Point=class Point{constructor(x,y,dataPtr){this.x=x,this.y=y,this.dataPtr=dataPtr}};static Rectangle=class Rectangle{constructor(x,y,w,h){this.x=x,this.y=y,this.w=w,this.h=h}contains(point){return this.x<=point.x&&point.x<=this.x+this.w&&this.y<=point.y&&point.y<=this.y+this.h}intersect(rectangle){return!(rectangle.x>this.x+this.w||rectangle.x+rectangle.w<this.x||rectangle.y>this.y+this.h||rectangle.y+rectangle.h<this.y)}wrap(rectangle){return this.x<=rectangle.x&&rectangle.x+rectangle.w<=this.x+this.w&&this.y<=rectangle.y&&rectangle.y+rectangle.h<=this.y+this.h}};constructor(boundary,capacity=5){if(!(boundary instanceof Quadtree.Rectangle))throw new Error("[Quadtree::constructor] boundary must be a Quadtree.Rectangle");this.boundary=boundary,this.capacity=capacity,this.points=[],this.divided=!1}get children(){return this.divided?[this.northwest,this.northeast,this.southwest,this.southeast]:[]}clear(){this.points=[],this.divided=!1,delete this.northeast,delete this.northwest,delete this.southeast,delete this.southwest}subdivide(){if(!this.divided){const{x:x,y:y,w:w,h:h}=this.boundary,ne=new Quadtree.Rectangle(x+w/2,y,w/2,h/2),nw=new Quadtree.Rectangle(x,y,w/2,h/2),se=new Quadtree.Rectangle(x+w/2,y+h/2,w/2,h/2),sw=new Quadtree.Rectangle(x,y+h/2,w/2,h/2);this.northwest=new Quadtree(nw),this.northeast=new Quadtree(ne),this.southwest=new Quadtree(sw),this.southeast=new Quadtree(se),this.divided=!0;for(const p of this.points)this.insert(p);this.points=[]}}insert(...points){for(const point of points){if(!this.boundary.contains(point))return!1;if(this.divided)return this.northeast.insert(point)||this.northwest.insert(point)||this.southeast.insert(point)||this.southwest.insert(point);if(this.points.length<this.capacity)return this.points.push(point),!0;this.subdivide(),this.insert(point)}}getRegion(x,y){if(!this.subtrees)return this;const index=(x>=this.x+this.width/2?1:0)+(y>=this.y+this.height/2?2:0);return this.children[index].getRegion(x,y)}getNeighboringRegions(region){if(!(region instanceof Quadtree))throw new Error("[Quadtree::getNeighboringRegions] region must be a Quadtree");const neighbors=[],left=region.x<this.x,right=region.x+region.width>this.x+this.width,top=region.y<this.y,bottom=region.y+region.height>this.y+this.height;return left&&top&&neighbors.push(this.children[0]),right&&top&&neighbors.push(this.children[1]),left&&bottom&&neighbors.push(this.children[2]),right&&bottom&&neighbors.push(this.children[3]),neighbors.filter(neighbor=>neighbor&&neighbor.boundary.intersect(region))}query(range){if(!(range instanceof Quadtree.Rectangle))throw new Error("[Quadtree::query] range must be a Quadtree.Rectangle");if(!this.divided){if(range.wrap(this.boundary))return this.points;if(range.intersect(this.boundary)){const found=[];for(const p of this.points)range.contains(p)&&found.push(p);return found}return[]}if(range.wrap(this.boundary))return this.getAllPoints();const found=[];return found.push(...this.northwest.query(range)),found.push(...this.northeast.query(range)),found.push(...this.southwest.query(range)),found.push(...this.southeast.query(range)),found}show(color=20){noFill(),stroke(color),strokeWeight(1),strokeRect(this.boundary.x,this.boundary.y,this.boundary.w-1,this.boundary.h-1),this.divided&&(this.northeast.show(),this.northwest.show(),this.southeast.show(),this.southwest.show())}getAllPoints(){if(!this.divided)return this.points;const points=[];for(const region of this.children)points.push(...region.getAllPoints());return points}size(){let n=this.points.length;for(const region of this.children)n+=region.size();return n}}export{PI,createCanvas,createImageManager,radian,degree,angleToVector,vectorToAngle,angleBetweenVectors,dist,mag,map,pow,abs,sqrt,min,max,clamp,round,floor,ceil,random,sin,cos,tan,asin,acos,atan,atan2,sinh,cosh,exp,log,log10,mean,median,mode,variance,std,perlin,noiseDetails,PerlinNoise,RGB,HEX,HSL,Vector,Matrix,Path,Quadtree};