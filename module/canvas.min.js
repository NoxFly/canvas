/**
 * @copyright   Copyright (C) 2019 - 2021 Dorian Thivolle All rights reserved.
 * @license     GNU General Public License version 3 or later; see LICENSE.txt
 * @author		Dorian Thivolle
 * @name		canvas
 * @package		NoxFly/canvas
 * @see			https://github.com/NoxFly/canvas
 * @since		30 Dec 2019
 * @version		{1.4.2}
 */
export let ctx=null,canvas=null,width=0,height=0,realWidth=0,realHeight=0;export let mouseX=0,mouseY=0;export let fps=60;export var pixels=void 0;export const documentWidth=()=>document.documentElement.clientWidth;export const documentHeight=()=>document.documentElement.clientHeight;export let MIN_DOC_SIZE=Math.min(documentWidth(),documentHeight());export const PI=Math.PI;export const isDevice={mobile:/iPhone|iPad|iPod|Android/i.test(navigator.userAgent),ios:/iPad|iPhone|iPod/.test(navigator.userAgent),android:/Android/.test(navigator.userAgent)};export const mouseDirection={x:0,y:0};export const moveTo=(x,y)=>ctx.moveTo(x,y);export const lineTo=(x,y)=>ctx.lineTo(x,y);export const arcTo=(x1,y1,x2,y2,r)=>ctx.arcTo(x1,y1,x2,y2,r);export const line=(x1,y1,x2,y2)=>{beginPath(),moveTo(x1,y1),lineTo(x2,y2),NOX_PV.bStroke&&ctx.stroke(),closePath()};export const polyline=(...values)=>{if(values.length%2!=0)return console.error("The function polyline must take an even number of values");beginPath(),values.length>0&&moveTo(values[0],values[1]);for(let i=2;i<values.length;i+=2){const x=values[i],y=values[i+1];lineTo(x,y)}NOX_PV.bStroke&&ctx.stroke(),NOX_PV.bFill&&ctx.fill(),closePath()};export const arc=(x,y,r,start,end,antiClockwise=!1)=>{beginPath(),ctx.arc(x,y,r,start,end,antiClockwise),NOX_PV.bStroke&&ctx.stroke(),NOX_PV.bFill&&ctx.fill(),closePath()};export const circle=(x,y,r)=>{arc(x,y,r,0,2*PI)};export const fillRect=(x,y,w,h)=>{ctx.fillRect(x,y,w,h)};export const strokeRect=(x,y,w,h)=>{ctx.strokeRect(x,y,w,h)};export const rect=(x,y,w,h)=>{ctx.rect(x,y,w,h),NOX_PV.bFill&&ctx.fill(),NOX_PV.bStroke&&ctx.stroke()};export const roundRect=(x=0,y=0,w=0,h=0,radius=0,radiusTR,radiusBR,radiusBL)=>{void 0===radiusTR&&(radiusTR=radius),void 0===radiusBR&&(radiusBR=radius),void 0===radiusBL&&(radiusBL=radius);const x1=x+(radius=min(max(0,radius),50)),y1=y,x2=x+w-(radiusTR=min(max(0,radiusTR),50)),y2=y,x3=x+w,y3=y+h-(radiusBR=min(max(0,radiusBR),50)),x4=x+(radiusBL=min(max(0,radiusBL),50)),y4=y+h,x5=x,y5=y+radius;beginPath(),moveTo(x1,y1),lineTo(x2,y2),arcTo(x2+radiusTR,y2,x2+radiusTR,y2+radiusTR,radiusTR),lineTo(x3,y3),arcTo(x3,y3+radiusBR,x3-radiusBR,y3+radiusBR,radiusBR),lineTo(x4,y4),arcTo(x4-radiusBL,y4,x,y4-radiusBL,radiusBL),lineTo(x5,y5),arcTo(x5,y5-radius,x1,y1,radius),NOX_PV.bStroke&&ctx.stroke(),NOX_PV.bFill&&ctx.fill(),closePath()};export const path=p=>{if(!(p=p.trim()).startsWith("M"))return;p=p.split(" ");let mode="M";const modes={M:{n:2,f:(x,y)=>moveTo(x,y)},L:{n:2,f:(x,y)=>lineTo(x,y)},H:{n:1,f:(x,y)=>lineTo(x,y)},V:{n:1,f:(y,x)=>lineTo(x,y)},A:{n:6,f:(x,y,r,start,end,antiClockwise)=>ctx.arc(x,y,r,radian(start),radian(end),1===antiClockwise)},Z:{n:0,f:()=>lineTo(parseFloat(p[1]),parseFloat(p[2]))}},reg=new RegExp(`^[${Object.keys(modes).join("")}]|(-?d+(.d+)?)$`,"i");if(0===p.filter(point=>reg.test(point)).length)return;if(p.length<3)return;const d=[],lastIdx=p.length-1;for(let i=0;i<p.length;i++){const point=p[i];if(/[a-z]/i.test(point)){if(mode=point,"Z"===mode){if(i!==lastIdx)return;d.push("Z")}if(["z"].includes(mode))return;const nArg=modes[mode.toUpperCase()].n;if(lastIdx-nArg<i)return;const lastPos={x:0,y:0};if(d.length>0){const prev=d[d.length-1],hv=["H","V"].indexOf(prev[0]);if(-1!==hv)lastPos.x=prev[1+hv],lastPos.y=prev[2-hv];else{const k=1;lastPos.x=prev[k],lastPos.y=prev[k+1]}}const arr=[mode.toUpperCase()],hv=["H","V"].indexOf(arr[0]);for(let j=0;j<nArg;j++){i++;const n=parseFloat(p[i]);if(isNaN(n))return;arr.push(n)}if(-1!==hv&&arr.push(lastPos[Object.keys(lastPos)[1-hv]]),"A"===arr[0]&&(arr[1]-=arr[3]),/[mlhva]/.test(mode)&&("v"===mode?arr[1]+=lastPos.y:"h"===mode?arr[1]+=lastPos.x:(arr[1]+=lastPos.x,arr[2]+=lastPos.y)),d.push(arr),"A"===arr[0]){const angle=radian(arr[5]),x=arr[1]+cos(angle)*arr[3];y=arr[2]+sin(angle)*arr[3],d.push(["M",x,y])}}}beginPath(),d.forEach(step=>{"string"==typeof step?modes[step].f():modes[step[0]].f(...step.slice(1))}),NOX_PV.bFill&&ctx.fill(),NOX_PV.bStroke&&ctx.stroke(),closePath()};export const text=(txt,x=0,y=0)=>{if(/\n/.test(txt)){const size=NOX_PV.fontSize.replace(/(\d+)(\w+)?/,"$1");txt=txt.split("\n");for(let i=0;i<txt.length;i++)ctx.fillText(txt[i],x,y+i*size)}else ctx.fillText(txt,x,y)};export const setFont=(size,font)=>{ctx.font=`${size}px ${font}`,NOX_PV.fontSize=`${size}px`,NOX_PV.fontFamily=font};export const fontSize=size=>{ctx.font=`${size}px ${NOX_PV.fontFamily}`,NOX_PV.fontSize=`${size}px`};export const fontFamily=font=>{ctx.font=`${NOX_PV.fontSize} ${font}`,NOX_PV.fontFamily=font};export const alignText=alignment=>{ctx.textAlign=["left","right","center","start","end"].indexOf(alignment)>-1?alignment:"left"};export const bezierCurveTo=(cp1x,cp1y,cp2x,cp2y,x,y)=>{ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)};export const quadraticCurveTo=(cpx,cpy,x,y)=>{ctx.quadraticCurveTo(cpx,cpy,x,y)};export const push=()=>ctx.save();export const pop=()=>ctx.restore();export const translate=(x,y)=>ctx.translate(NOX_PV.centerX+x,NOX_PV.centerY+y);export const rotate=degree=>ctx.rotate(radian(degree));export const clip=(...args)=>ctx.clip(...args);export const scale=(x,y)=>ctx.scale(x,y);export const noFill=()=>{NOX_PV.bFill=!1};export const noStroke=()=>{NOX_PV.bStroke=!1};export const background=(...color)=>{canvas.style.backgroundColor=NOX_PV.colorTreatment(...color)};export const stroke=(...color)=>{ctx.strokeStyle=NOX_PV.colorTreatment(...color),NOX_PV.bStroke=!0};export const strokeWeight=weight=>{ctx.lineWidth=weight};export const linecap=style=>{ctx.lineCap=["butt","round","square"].indexOf(style)>-1?style:"butt"};export const fill=(...color)=>{ctx.fillStyle=NOX_PV.colorTreatment(...color),NOX_PV.bFill=!0};export const createLinearGradient=(x1,y1,x2,y2)=>ctx.createLinearGradient(x1,y1,x2,y2);export const makeLinearGradient=(x1,y1,x2,y2,...params)=>{if(params.length%2!=0)return console.error("you have to tell params by pair (offset, color). Odd number of arguments given.");const grad=createLinearGradient(x1,y1,x2,y2);for(let i=0;i<params.length;i+=2){const offset=params[i],color=NOX_PV.colorTreatment(params[i+1]);grad.addColorStop(offset,color)}return grad};export const clearRect=(x,y,w,h)=>ctx.clearRect(x,y,x+w,y+h);export const beginPath=()=>ctx.beginPath();export const closePath=()=>ctx.closePath();export const drawFocusIfNeeded=(elementOrPath2D,element=null)=>{null!==element||elementOrPath2D instanceof Path2D?ctx.drawFocusIfNeeded(elementOrPath2D,element):ctx.drawFocusIfNeeded(elementOrPath2D)};export const setLineDash=array=>{if(!Array.isArray(array))return console.error("Array type expected. Got "+typeof array);ctx.setLineDash(array)};export const getLineDash=()=>ctx.getLineDash();export const globalAlpha=globalAlpha=>{ctx.globalAlpha=globalAlpha};export const globalCompositeOperation=type=>{ctx.globalCompositeOperation=type};export const setSmoothingQuality=quality=>{["low","medium","high"].includes(quality)&&(ctx.imageSmoothingQuality=quality)};export const isPointInPath=function(x,y,fillRule=null){return ctx.isPointInPath(...arguments)};export const isPointInStroke=function(x,y){return ctx.isPointInStroke(...arguments)};export const getTransform=()=>ctx.getTransform();export const lineDashOffset=(value=0)=>{ctx.lineDashOffset=value};export const lineJoin=type=>{ctx.lineJoin=type};export const measureText=text=>ctx.measureText(text);export const resetTransform=()=>ctx.resetTransform();export const setTransform=(...transform)=>ctx.setTransform(...transform);export const createPattern=(image,repetition)=>{ctx.createPattern(image,repetition)};export const createImageData=function(widthOrImageData,height=null){return ctx.createImageData(...arguments)};export const putImageData=(imageData,dx,dy,dirtyX=null,dirtyY=null,dirtyWidth=null,dirtyHeight=null)=>{null===dirtyX?ctx.putImageData(imageData,dx,dy):ctx.putImageData(imageData,dx,dy,dirtyX,dirtyY,dirtyWidth,dirtyHeight)};export const getImageData=(sx,sy,sw,sh)=>ctx.getImageData(sx,sy,sw,sh);export const drawImage=(image,sx,sy,sWidth=null,sHeight=null,dx=null,dy=null,dWidth=null,dHeight=null)=>{null===sWidth?ctx.drawImage(image,sx,sy):null===dx?ctx.drawImage(image,sx,sy,sWidth,sHeight):ctx.drawImage(image,sx,sy,sWidth,sHeight,dx,dy,dWidth,dHeight)};export const radian=deg=>deg*(PI/180);export const degree=rad=>rad*(180/PI);export const angleToVector=angle=>new Vector(cos(angle),sin(angle));export const vectorToAngle=vec=>{const baseVector=new Vector(1,0);return angleBetweenVectors(baseVector,vec)};export const angleBetweenVectors=(a,b)=>{const ab=a.x*b.x+a.y*b.y+a.z*b.z,cosO=ab/(a.mag*b.mag),O=acos(cosO);return O};export const dist=(a,b)=>{let s=0;if(a.x&&b.x){const x=b.x-a.x;s+=x*x}if(a.y&&b.y){const y=b.y-a.y;s+=y*y}if(a.z&&b.z){const z=b.z-a.z;s+=z*z}return sqrt(s)};export const map=(arrayOrValue,start1,end1,start2,end2)=>{const m=val=>(val-start1)*(end2-start2)/(end1-start1)+start2;return"number"==typeof arrayOrValue?m(arrayOrValue):arrayOrValue.map(val=>m(val))};export const pow=(n,p=2)=>Math.pow(n,p);export const abs=n=>n>=0?n:-n;export const sqrt=n=>Math.sqrt(n);export const min=(...values)=>Math.min(...values);export const max=(...values)=>Math.max(...values);export const round=n=>Math.round(n);export const floor=n=>Math.floor(n);export const ceil=n=>Math.ceil(n);export const trunc=n=>Math.trunc(n);export const random=(iMin,iMax=0)=>floor(Math.random()*(max(iMin,iMax)-min(iMin,iMax)+1))+min(iMin,iMax);export const sin=x=>Math.sin(x);export const cos=x=>Math.cos(x);export const tan=x=>Math.tan(x);export const asin=x=>Math.asin(x);export const acos=x=>Math.acos(x);export const atan=x=>Math.atan(x);export const atan2=(x,y)=>Math.atan2(y,x);export const sinh=x=>Math.sinh(x);export const cosh=x=>Math.cosh(x);export const exp=x=>Math.exp(x);export const log=x=>Math.log(x);export const log10=x=>Math.log10(x);export const sum=(...values)=>values.reduce((a,b)=>a+b);export const mean=(...values)=>sum(...values)/values.length;export const median=(...values)=>{if(0===values.length)return 0;values.sort((a,b)=>a-b);const half=floor(values.length/2);return values.length%2?values[half]:(values[half-1]+values[half])/2};export const mode=(...values)=>values.reduce((a,b,i,arr)=>arr.filter(v=>v===a).length>=arr.filter(v=>v===b).length?a:b,null);export const variance=(...values)=>values.reduce((a,b)=>a+pow(b-mean(...values)),0);export const std=(...values)=>sqrt(variance(...values));export const easeLinear=(t,b,c,d)=>c*t/d+b;export const easeInQuad=(t,b,c,d)=>c*(t/=d)*t+b;export const easeOutQuad=(t,b,c,d)=>-c*(t/=d)*(t-2)+b;export const easeInOutQuad=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t+b:-c/2*(--t*(t-2)-1)+b;export const easeInSine=(t,b,c,d)=>-c*cos(t/d*(PI/2))+c+b;export const easeOutSine=(t,b,c,d)=>c*sin(t/d*(PI/2))+b;export const easeInOutSine=(t,b,c,d)=>-c/2*(cos(PI*t/d)-1)+b;export const easeInExpo=(t,b,c,d)=>0===t?b:c*pow(2,10*(t/d-1))+b;export const easeOutExpo=(t,b,c,d)=>t===d?b+c:c*(1-pow(2,-10*t/d))+b;export const easeInOutExpo=(t,b,c,d)=>0===t?b:t===d?b+c:(t/=d/2)<1?c/2*pow(2,10*(t-1))+b:c/2*(2-pow(2,-10*--t))+b;export const easeInCirc=(t,b,c,d)=>-c*(sqrt(1-(t/=d)*t)-1)+b;export const easeOutCirc=(t,b,c,d)=>c*sqrt(1-(t=t/d-1)*t)+b;export const easeInOutCirc=(t,b,c,d)=>(t/=d/2)<1?-c/2*(sqrt(1-t*t)-1)+b:c/2*(sqrt(1-(t-=2)*t)+1)+b;export const easeInCubic=(t,b,c,d)=>c*(t/=d)*t*t+b;export const easeOutCubic=(t,b,c,d)=>c*((t=t/d-1)*t*t+1)+b;export const easeInOutCubic=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t*t+b:c/2*((t-=2)*t*t+2)+b;export const easeInQuart=(t,b,c,d)=>c*(t/=d)*t*t*t+b;export const easeOutQuart=(t,b,c,d)=>-c*((t=t/d-1)*t*t*t-1)+b;export const easeInOutQuart=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t*t*t+b:-c/2*((t-=2)*t*t*t-2)+b;export const easeInQuint=(t,b,c,d)=>c*(t/=d)*t*t*t*t+b;export const easeOutQuint=(t,b,c,d)=>c*((t=t/d-1)*t*t*t*t+1)+b;export const easeInOutQuint=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t*t*t*t+b:c/2*((t-=2)*t*t*t*t+2)+b;export const easeInBack=(t,b,c,d)=>c*(t/=d)*t*(2.7*t-1.7)+b;export const easeOutBack=(t,b,c,d)=>c*((t=t/d-1)*t*(2.7*t+1.7)+1)+b;export const easeInOutBack=(t,b,c,d)=>(t/=d/2)<1?c/2*(t*t*(3.5925*t-1.7))+b:c/2*((t-=2)*t*(3.5925*t+1.7)+2)+b;export const easeInElastic=(t,b,c,d)=>NOX_PV.easeElastic("in",t,b,c,d);export const easeOutElastic=(t,b,c,d)=>NOX_PV.easeElastic("out",t,b,c,d);export const easeInOutElastic=(t,b,c,d)=>NOX_PV.easeElastic("inout",t,b,c,d);export const frameRate=f=>{f>=0&&(NOX_PV.interval=1e3/f)};export const getSwipe=()=>NOX_PV.lastSwipe;export const isKeyDown=key=>NOX_PV.keys[key];export const isKeyUp=key=>!NOX_PV.keys[key];export const rendering=(x,y=null)=>new Vector((x instanceof Vector&&!y?x.x:x)*width/realWidth,(x instanceof Vector&&!y?x.y:y)*height/realHeight);export const renderingX=x=>x*width/realWidth;export const renderingY=y=>y*height/realHeight;export const mouseDir=()=>NOX_PV.isPointerLocked?mouseDirection:mouseX>NOX_PV.oldMouseX&&mouseY>NOX_PV.oldMouseY?"BOTTOM_RIGHT":mouseX>NOX_PV.oldMouseX&&mouseY<NOX_PV.oldMouseY?"TOP_RIGHT":mouseX<NOX_PV.oldMouseX&&mouseY<NOX_PV.oldMouseY?"TOP_LEFT":mouseX<NOX_PV.oldMouseX&&mouseY>NOX_PV.oldMouseY?"BOTTOM_LEFT":mouseX>NOX_PV.oldMouseX&&mouseY===NOX_PV.oldMouseY?"RIGHT":mouseX===NOX_PV.oldMouseX&&mouseY>NOX_PV.oldMouseY?"DOWN":mouseX===NOX_PV.oldMouseX&&mouseY<NOX_PV.oldMouseY?"UP":mouseX<NOX_PV.oldMouseX&&mouseY===NOX_PV.oldMouseY?"LEFT":null;export const enablePCswipe=bool=>{NOX_PV.swipePCEnable="boolean"!=typeof bool||bool,NOX_PV.swipePCEnable?(document.addEventListener("mousedown",handleTouchStart,!1),document.addEventListener("mousemove",handleTouchMove,!1)):(document.removeEventListener("mousedown",handleTouchStart,!0),document.removeEventListener("mousemove",handleTouchMove,!0))};export const setPixelResolution=(w,h)=>{w<=0||h<=0||(canvas&&ctx?(realWidth=w,realHeight=h,canvas.width=realWidth,canvas.height=realHeight,canvas.style.width=width+"px",canvas.style.height=height+"px"):console.warn("No canvas created yet, so cannot apply changes for its size."))};export const setCanvasSize=(newWidth,newHeight)=>{canvas&&ctx?(canvas.style.width=newWidth+"px",canvas.style.height=newHeight+"px",canvas.width=newWidth,canvas.height=newHeight,width=newWidth,height=newHeight):console.warn("No canvas created yet, so cannot apply changes for its size.")};export const createCanvas=(w=null,h=null,bg="#000",requestPointerLock=!1,container=document.body)=>!1 in NOX_PV?console.warn("[Warning] createCanvas : usable only setup() function."):(null==w&&null==h&&(w=documentWidth(),h=documentHeight()),w<=0||h<=0?void console.warn("Canvas size must be higher than 0"):(null!=canvas&&(document.querySelector("#"+canvas.id).remove(),canvas=null,ctx=null),canvas=document.createElement("canvas"),width=w,height=h,canvas.width=width,canvas.height=height,canvas.style.width=width,canvas.style.height=height,realWidth=width,realHeight=height,canvas.id="dynamic-canvas",canvas.style.background=NOX_PV.colorTreatment(bg),container.appendChild(canvas),requestPointerLock&&(canvas.requestPointerLock=canvas.requestPointerLock||canvas.mozRequestPointerLock,document.exitPointerLock=document.exitPointerLock||document.mozExitPointerLock,document.addEventListener("pointerlockchange",()=>{document.pointerLockElement&&"dynamic-canvas"==document.pointerLockElement.id||(NOX_PV.isPointerLocked=!1)},!1),canvas.addEventListener("click",()=>{NOX_PV.isPointerLocked||(NOX_PV.isPointerLocked=!0,canvas.requestPointerLock())})),ctx=canvas.getContext("2d"),NOX_PV.hasInitAllEventHandlers||initializeAllEventHandlers(),canvas));export const showGuideLines=bool=>{NOX_PV.bGuideLines="boolean"==typeof bool&&bool};let drawCond=()=>!0;export const setDrawCondition=(condition=null)=>{condition&&(drawCond=condition)};const drawLoop=()=>{!0===NOX_PV.loop&&requestAnimationFrame(drawLoop);const t0=performance.now();if(NOX_PV.logPerfs&&0===NOX_PV.drawLoopInfo.it&&(NOX_PV.drawLoopInfo.start=t0),NOX_PV.now=Date.now(),NOX_PV.delta=NOX_PV.now-NOX_PV.then,"function"==typeof NOX_PV.updateFunc&&NOX_PV.updateFunc(NOX_PV.timer.asMilliseconds()),NOX_PV.logPerfs&&(NOX_PV.drawLoopInfo.t1+=performance.now()-t0),NOX_PV.delta>NOX_PV.interval&&(NOX_PV.then=NOX_PV.now-NOX_PV.delta%NOX_PV.interval,NOX_PV.then-NOX_PV.firstThen>99999&&(NOX_PV.firstThen=NOX_PV.now,NOX_PV.then=NOX_PV.firstThen,NOX_PV.counter=0),NOX_PV.time_el=(NOX_PV.then-NOX_PV.firstThen)/1e3||1,NOX_PV.counter++,fps=round(NOX_PV.counter/NOX_PV.time_el),"function"==typeof NOX_PV.drawFunc&&ctx&&drawCond())){const t=performance.now();push(),clearRect(0,0,width,height),NOX_PV.drawFunc(),NOX_PV.bGuideLines&&(push(),fill("#46eaea"),stroke("#46eaea"),strokeWeight(1),line(0,mouseY,width,mouseY),line(mouseX,0,mouseX,height),text(`${floor(mouseX)}, ${floor(mouseY)}`,mouseX+5,mouseY-5),pop()),pop(),NOX_PV.drawLoopInfo.t2+=performance.now()-t}if(NOX_PV.logPerfs&&(NOX_PV.drawLoopInfo.it=(NOX_PV.drawLoopInfo.it+1)%NOX_PV.drawLoopInfo.freq,0===NOX_PV.drawLoopInfo.it)){NOX_PV.drawLoopInfo.t1/=NOX_PV.drawLoopInfo.freq,NOX_PV.drawLoopInfo.t2/=NOX_PV.drawLoopInfo.freq;const t1=floor(100*NOX_PV.drawLoopInfo.t1)/100,t2=floor(100*NOX_PV.drawLoopInfo.t2)/100,t3=floor(100*(t1+t2))/100;NOX_PV.drawLoopInfo.t1=0,NOX_PV.drawLoopInfo.t2=0;const data={update:{ms:t1},draw:{ms:t2},total:{ms:t3}};console.table(data)}};export const noLoop=()=>{NOX_PV.loop=!1};export const enableSmoothing=()=>{ctx&&(ctx.imageSmoothingEnabled=!0)};export const disableSmoothing=()=>{ctx&&(ctx.imageSmoothingEnabled=!1)};export const loadPixels=()=>{if(ctx instanceof CanvasRenderingContext2D&&canvas instanceof HTMLCanvasElement){NOX_PV.pixels=ctx.createImageData(canvas.width,canvas.height),pixels=NOX_PV.pixels.data;for(let i=0;i<width*height;i++)pixels[4*i+3]=255}else console.warn("Can't load canvas's pixels : no existing context found.")};export const updatePixels=()=>{void 0!==pixels&&ctx instanceof CanvasRenderingContext2D&&(NOX_PV.pixels.data=pixels,ctx.putImageData(NOX_PV.pixels,0,0))};export const perlin=(x,y=0)=>(NOX_PV.perlin.seed&&0!==NOX_PV.perlin.seed.length||(NOX_PV.perlin.seed=NOX_PV.perlin.generateSeed()),NOX_PV.perlin.get(x,y));export const noiseDetails=detailLevel=>{"number"==typeof detailLevel&&(NOX_PV.perlin.lod=detailLevel)};export const generateUUID=()=>{const d0=4294967295*Math.random()|0,d1=4294967295*Math.random()|0,d2=4294967295*Math.random()|0,d3=4294967295*Math.random()|0;return NOX_PV.lut[255&d0]+NOX_PV.lut[d0>>8&255]+NOX_PV.lut[d0>>16&255]+NOX_PV.lut[d0>>24&255]+"-"+NOX_PV.lut[255&d1]+NOX_PV.lut[d1>>8&255]+"-"+NOX_PV.lut[d1>>16&15|64]+NOX_PV.lut[d1>>24&255]+"-"+NOX_PV.lut[63&d2|128]+NOX_PV.lut[d2>>8&255]+"-"+NOX_PV.lut[d2>>16&255]+NOX_PV.lut[d2>>24&255]+NOX_PV.lut[255&d3]+NOX_PV.lut[d3>>8&255]+NOX_PV.lut[d3>>16&255]+NOX_PV.lut[d3>>24&255]};export const handleTouchStart=e=>{NOX_PV.isMouseDown=!0,"function"==typeof mouseDown&&mouseDown(e);const getTouches=e2=>e2.touches||[{clientX:e.clientX,clientY:e.clientY},null],firstTouch=getTouches(e)[0];NOX_PV.swipexDown=firstTouch.clientX,NOX_PV.swipeyDown=firstTouch.clientY};export const handleTouchMove=e=>{if("function"==typeof mouseMove&&NOX_PV.isMouseDown&&mouseMove(e),!NOX_PV.swipexDown||!NOX_PV.swipeyDown)return;let xUp,yUp;e.touches?(xUp=e.touches[0].clientX,yUp=e.touches[0].clientY):(xUp=e.clientX,yUp=e.clientY);const xDiff=NOX_PV.swipexDown-xUp,yDiff=NOX_PV.swipeyDown-yUp;let event,swipeDir;abs(xDiff)>abs(yDiff)?xDiff>0?(swipeDir="left")&&(event=new CustomEvent("swipeleft",{detail:{swipe:"left"}})):(swipeDir="right")&&(event=new CustomEvent("swiperight",{detail:{swipe:"right"}})):yDiff>0?(swipeDir="up")&&(event=new CustomEvent("swipeup",{detail:{swipe:"up"}})):(swipeDir="down")&&(event=new CustomEvent("swipedown",{detail:{swipe:"down"}})),canvas.dispatchEvent(event),NOX_PV.lastSwipe=swipeDir,NOX_PV.swipexDown=null,NOX_PV.swipeyDown=null};export class RGB{constructor(r,g=null,b=null,a=255){this.color={r:0,g:0,b:0},void 0===r&&(r=0),null!==g&&null===b&&(a=g,g=b=r),null===g&&(g=r,b=r),this.r=r,this.g=g,this.b=b,this.a=a}valueInInterval(val){return val<0||val>255?(console.error(`Color interval [0 - 255] no repespected (${val} given)`),min(max(val,0),255)):val}get r(){return this.color.r}get g(){return this.color.g}get b(){return this.color.b}get a(){return this.color.a}set r(val){this.color.r=this.valueInInterval(val)}set g(val){this.color.g=this.valueInInterval(val)}set b(val){this.color.b=this.valueInInterval(val)}set a(val){this.color.a=this.valueInInterval(val)}set(r,g,b,a=null){this.r=r,this.g=g,this.b=b,null!==a&&(this.a=a)}toString(){return`rgb${255!=this.a?"a":""}(${this.r}, ${this.g}, ${this.b}${255!=this.a?`, ${round(this.a/255*10)/10}`:""})`}intVal(){return[this.r,this.g,this.b,this.a]}toHEX(){const r=Number(this.r).toString(16);r.length<2&&(r="0"+r);const g=Number(this.g).toString(16);g.length<2&&(g="0"+g);const b=Number(this.b).toString(16);b.length<2&&(b="0"+b);const rgb="#"+r+g+b;return new HEX(rgb)}toHSL(){const r=this.r/255,g=this.g/255,b=this.b/255,imax=max(r,g,b),imin=min(r,g,b);let h,s,l=(imax+imin)/2;if(imax===imin)h=s=0;else{const d=imax-imin;switch(s=l>.5?d/(2-imax-imin):d/(imax+imin),imax){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return new HSL(round(10*h)/10,round(10*s)/10,round(10*l)/10)}}export class HEX{constructor(hexaColor){this.color={int:0,str:"#000000"},this.set(hexaColor)}toString(){return this.color.str}intVal(){return this.color.int}set(hexaColor){if("number"==typeof hexaColor){this.color.int=hexaColor;const h=hexaColor.toString(16)+"";this.color.str="#"+(4===h.length?"00":"")+h}else"string"==typeof hexaColor&&/^#?([0-9a-f]{3}){1,2}$/i.test(hexaColor)?(3===(hexaColor=hexaColor.replace("#","")).length&&(hexaColor=hexaColor[0].repeat(2)+hexaColor[1].repeat(2)+hexaColor[2].repeat(2)),this.color.str="#"+hexaColor,this.color.int=parseInt(hexaColor,16)):console.error(`Given parameter isn't a recognized hexadecimal number: ${hexaColor}`)}toRGB(){const r=(16711680&this.intVal())>>>16,g=(65280&this.intVal())>>>8,b=255&this.intVal();return new RGB(r,g,b)}toHSL(){return this.toRGB().toHSL()}}export class HSL{constructor(hue,saturation=.5,light=.5){this.color={h:0,s:0,l:0},"number"!=typeof hue&&(console.error(`Hue given parameter isn't a recognized number value: ${hue}`),hue=0),this.h=hue,this.s=saturation,this.l=light}get h(){return this.color.h}get s(){return this.color.s}get l(){return this.color.l}set h(hue){this.color.h=hue>=0?hue%360:360-abs(hue)%360}set s(saturation){this.color.s=min(max(saturation,0),1)}set l(luminosity){this.color.l=min(max(luminosity,0),1)}add(hueToAdd){this.h=this.h+hueToAdd}sub(hueToSub){this.h=this.h-hueToSub}lighten(lightToAdd){this.l=this.l+lightToAdd}obscure(lightToSub){this.l=this.l-lightToSub}addSat(saturationToAdd){this.s=this.s+saturationToAdd}subSat(saturationToSub){this.s=this.s-saturationToSub}toString(){return`hsl(${this.h}, ${100*this.s}%, ${100*this.l}%)`}intVal(){return this.toHEX().intVal()}toHEX(){return this.toRGB().toHEX()}toRGB(){const C=(1-abs(2*this.l-1))*this.s,hh=this.h/60,X=C*(1-abs(hh%2-1));let r,g,b;r=g=b=0,hh>=0&&hh<1?[r,g]=[C,X]:hh>=1&&hh<2?[r,g]=[X,C]:hh>=2&&hh<3?[g,b]=[C,X]:hh>=3&&hh<4?[g,b]=[X,C]:[r,b]=hh>=4&&hh<5?[X,C]:[C,X];const m=this.l-C/2;return r=round(255*(r+m)),g=round(255*(g+m)),b=round(255*(b+m)),new RGB(r,g,b)}}export class PerlinNoise{static mapNumberTypes=["default","rgb","hsl"];static getMapNumberTypeIndex=typeStr=>PerlinNoise.mapNumberTypes.indexOf(typeStr.toLowerCase());constructor(lod=10,x=0,y=0,w=width,h=height,mapNumber="default"){this.lod=lod,this.seed=NOX_PV.perlin.generateSeed(),this.start={x:x,y:y},this.size={width:w,height:h},this.array=[],this.numberMapStyle=PerlinNoise.getMapNumberTypeIndex(mapNumber),this.calculate()}setLOD(lod){const tmp=this.lod;this.lod=lod,tmp!==lod&&this.calculate()}regenerateSeed(){this.seed=NOX_PV.perlin.generateSeed(),this.calculate()}setMapNumber(mapNumber){if(mapNumber=PerlinNoise.getMapNumberTypeIndex(mapNumber),this.numberMapStyle===mapNumber)return;let Lmin=0,Lmax=NOX_PV.perlin.unit,Rmin=0,Rmax=NOX_PV.perlin.unit;this.numberMapStyle>0&&([Lmin,Lmax]=[0,1===this.numberMapStyle?255:360]),this.numberMapStyle=mapNumber,this.numberMapStyle>0&&([Rmin,Rmax]=[0,1===this.numberMapStyle?255:360]),this.array.forEach((row,i)=>{this.array[i]=map(this.array[i],Lmin,Lmax,Rmin,Rmax)})}calculate(){this.array=[];for(const y=this.start.y;y<this.start.y+this.size.height;y++){const row=[];for(const x=this.start.x;x<this.start.x+this.size.width;x++)row.push(NOX_PV.perlin.get(x,y,this.lod,this.seed));this.array.push(row)}this.numberMapStyle>0&&this.setMapNumber(PerlinNoise.mapNumberTypes[this.numberMapStyle])}}export class Time{static units={nano:ms=>1e8*ms,micro:ms=>1e3*ms,milli:(t,unit="milli")=>{switch(unit){case"nano":return t/1e8;case"micro":return t/1e3;case"seconds":return 1e3*t;case"minutes":return 6e4*t;default:return t}},seconds:ms=>ms/1e3,minutes:ms=>ms/6e4};constructor(startingTime,unity="milli"){void 0!==startingTime&&Object.keys(Time.units).includes(unity)?(this.start=Time.units.milli(startingTime,unity),this.staticTime=!0):(this.reset(),this.staticTime=!1)}asNanoseconds(){return Time.units.nano(this.asMilliseconds())}asMicroseconds(){return Time.units.micro(this.asMilliseconds())}asMilliseconds(){return Time.units.milli(this.staticTime?this.start:Date.now()-this.start)}asSeconds(){return Time.units.seconds(this.asMilliseconds())}asMinutes(){return Time.units.minutes(this.asMilliseconds())}reset(){this.start=Date.now()}}export class Vector{constructor(x,y=null,z=null){let dimension=1;this.coords={x:0,y:0,z:0};const tmp={x:0,y:0,z:0};x instanceof Vector?(dimension=x.dimension,tmp.x=x.x,tmp.y=x.y,tmp.z=x.z):(dimension=Array.from(arguments).filter(a=>"number"==typeof a).length,tmp.x=x,tmp.y=y,tmp.z=z),this.constants=Object.freeze({dimension:dimension}),this.set(tmp.x,tmp.y,tmp.z)}get dimension(){return this.constants.dimension}get x(){return this.coords.x}get y(){return this.coords.y}get z(){return this.coords.z}set x(x){this.coords.x=x}set y(y){this.dimension>1?this.coords.y=y:console.error("Cannot modify the Y of a 1D vector")}set z(z){this.dimension>2?this.coords.z=z:console.error(`Cannot modify the Y of a ${this.dimension}D vector`)}normalize(apply=!1){const norm=Math.hypot(this.x,this.y,this.z);return apply?(0!=norm&&(this.x=this.x/norm,this.dimension>1&&(this.y=this.y/norm,3===this.dimension&&(this.z=this.z/norm))),this):new Vector(this).normalize(!0)}set(x,y=null,z=null){if(x instanceof Vector)this.x=x.x,2===this.dimension&&(this.y=x.y),3===this.dimension&&(this.z=x.z);else{if("number"!=typeof x)return console.error("[Error] Vector::set : x parameter must be a number or a Vector");if(this.dimension>1){if(null!==y&&"number"!=typeof y)return console.error("[Error] Vector::set : y parameter must be a number");if(null!==z&&this.dimension>2&&"number"!=typeof z)return console.error("[Error] Vector::set : z parameter must be a number")}this.x=x,this.dimension>1&&(null!==y&&(this.y=y),3===this.dimension&&null!=z&&(this.z=z))}return this}add(x,y=null,z=null){return x instanceof Vector?this.set(this.x+x.x,this.y+x.y,this.z+x.z):(null===y&&(y=x),null===z&&(z=x),this.set(this.x+x,this.y+y,this.z+z))}mult(x,y=null,z=null){return x instanceof Vector?this.set(this.x*x.x,this.y*x.y,this.z*x.z):(null===y&&(y=x),null===z&&(z=x),this.set(this.x*x,this.y*y,this.z*z))}div(x,y=null,z=null){return x instanceof Vector?this.set(this.x/x.x,this.y/x.y,this.z/x.z):(null===y&&(y=x),null===z&&(z=x),this.set(this.x/x,this.y/y,this.z/z))}invert(antiClockwise=!1){return this.dimension>1&&(2===this.dimension?[this.x,this.y]=[this.y,this.x]:[this.x,this.y,this.z]=antiClockwise?[this.y,this.z,this.x]:[this.z,this.x,this.y]),this}get mag(){return Math.hypot(this.x,this.y,this.z)}setMag(newMag){return this.x=this.x*newMag/this.mag,this.dimension>1&&(this.y=this.y*newMag/this.mag),this.dimension>2&&(this.z=this.z*newMag/this.mag),this}toString(){return`{ x: ${this.x}${this.dimension>1?`, y: ${this.y}`:""}${this.dimension>2?`, z: ${this.z}`:""} }`}array(){const arr=[this.x];return this.dimension>1&&arr.push(this.y),this.dimension>2&&arr.push(this.z),arr}object(){let o={x:this.x};return this.dimension>1&&(o.y=this.y,this.dimension>2&&(o.z=this.z)),o}bow(x,y,style={}){if(3===this.dimension)return;style.strokeWeight?strokeWeight(style.strokeWeight):strokeWeight(1),style.stroke?stroke(style.stroke):stroke("#fff");let rotation=degree(vectorToAngle(this));this.y<0&&(rotation*=-1),push(),translate(x,y),line(0,0,this.x,this.y),linecap("round"),push(),translate(this.x,this.y),push(),rotate(rotation+25),line(0,0,-min(this.mag/2.5,10),0),rotate(-50),line(0,0,-min(this.mag/2.5,10),0),pop(),pop(),pop()}}export class Matrix{properties={array:[],width:0,height:0};constructor(...args){if(args.length>0)if(args[0]instanceof Matrix){this.properties.width=args[0].width,this.properties.height=args[0].height;for(let i=0;i<args[0].height;i++){const row=[];for(let j=0;j<args[0].width;j++)row.push(args[0].at(j,i));this.properties.array.push(row)}}else if("number"==typeof args[0]){let fill=0;const w=args[0];let h=w;args.length>1&&"number"==typeof args[1]&&(h=args[1],args.length>2&&"number"==typeof args[2]&&(fill=args[2]));for(let i=0;i<h;i++){const row=[];for(let j=0;j<w;j++)row.push(fill);this.properties.array.push(row)}this.properties.width=w,this.properties.height=h}else 1===args.length&&Array.isArray(args[0])&&args[0].every(a=>Array.isArray(a)&&a.length===args[0][0].length&&a.every(e=>"number"==typeof e))?(this.properties.array=args[0],args[0].length>0&&(this.properties.width=args[0][0].length),this.properties.height=args[0].length):args.every(a=>Array.isArray(a)&&a.length===args[0].length&&a.every(e=>"number"==typeof e))?(this.properties.array=args,this.properties.width=args[0].length,this.properties.height=args.length):console.error("[Error] Matrix constructor : Unrecognized parameters.");this.properties.size=Object.freeze({x:this.properties.width,y:this.properties.height}),delete this.properties.width,delete this.properties.height}get array(){return this.properties.array}get array1D(){return this.array.reduce((a,b)=>[...a,...b],[])}get width(){return this.properties.size.x}get height(){return this.properties.size.y}get dimension(){return this.properties.size}toString(uncluttered=!1){const sep=this.height>0?"\n":"",brackets_open=uncluttered?"":"[",brackets_close=uncluttered?"":"]",m=uncluttered?max(...this.array.map(a=>max(...a.map(e=>e.toString().length)))):0,_format=uncluttered?arr=>arr.map(e=>" ".repeat(6+m-2*e.toString().length)+e).join(" "):arr=>arr.join(", ");return brackets_open+sep+this.properties.array.map(a=>"\t"+brackets_open+_format(a)+brackets_close).join("\n")+sep+brackets_close}at(x,y){return"number"==typeof x&&"number"==typeof y&&x>-1&&y>-1&&x<this.width&&y<this.height?this.array[y][x]:null}set(x,y,value){null!==this.at(x,y)&&"number"==typeof value&&(this.array[y][x]=value)}equals(matrix){if(matrix.width!==this.width||matrix.height!==this.height)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++)if(matrix.at(j,i)!==this.at(j,i))return!1;return!0}get isSymmetrical(){for(let i=0;i<this.width;i++)for(let j=0;j<this.height;j++)if(this.at(i,j)!==this.at(j,i))return!1;return!0}get isSquare(){return this.width===this.height}get isIdentity(){return this.isSquare&&this.array.every((arr,i)=>arr.every((e,j)=>i===j&&1===e||i!==j&&0===e))}get isDiagonal(){return this.isSquare&&this.array.every((arr,i)=>arr.every((e,j)=>i===j&&0!==e||i!==j&&0===e))}get isTriangular(){const a=this.isLowerTri,b=this.isUpperTri;return a?!b:b}get isLowerTri(){if(!this.isSquare)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++){const e=this.at(j,i);if(j>=i&&0!==e)return!1}return!0}get isUpperTri(){if(!this.isSquare)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++){const e=this.at(j,i);if(j<=i&&0!==e)return!1}return!0}get diagonal(){return this.isSquare?this.array.map((arr,i)=>arr[i]):[]}get det(){if(!this.isSquare)return 0;if(this.isIdendity)return 1;if(this.isDiagonal||this.isTriangular){const diag=this.diagonal;return diag.reduce((acc,curr)=>acc*curr,1)}if(2===this.width)return this.at(0,0)*this.at(1,1)-this.at(1,0)*this.at(0,1);if(3===this.width){const[a,b,c,d,e,f,g,h,i]=this.array1D;return a*e*i+d*h*c+b*f*g-(g*e*c+d*b*i+a*h*f)}{const det=m=>1===m.length?m[0][0]:2===m.length?m[0][0]*m[1][1]-m[0][1]*m[1][0]:m[0].reduce((r,e,i)=>r+(-1)**(i+2)*e*det(m.slice(1).map(c=>c.filter((_,j)=>i!=j))),0);return det(this.array)}}add(matrix,onACopy=!1){if("op"in this||(this.op=(a,b)=>a+b),!(matrix instanceof Matrix)&&"number"!=typeof matrix)return console.error(`[Error] Matrix::add : Matrix expected, ${typeof matrix} given`),delete this.op,this;if(matrix instanceof Matrix&&(matrix.width!==this.width||matrix.height!==this.height))return console.error("[Error] Matrix::add : Cannot operate an addition between 2 matrices with different dimensions."),delete this.op,this;const result=onACopy?new Matrix(this):this,b=matrix instanceof Matrix;for(let i=0;i<result.height;i++)for(let j=0;j<result.width;j++)result.set(j,i,this.op(result.at(j,i),b?matrix.at(j,i):matrix));return delete this.op,result}sub(matrix,onACopy=!1){return this.op=(a,b)=>a-b,this.add(matrix,onACopy)}mult(matrixOrNumber,onACopy=!1){const m=matrixOrNumber,result=onACopy?new Matrix(this):this;if("number"==typeof m)for(let i=0;i<result.height;i++)for(let j=0;j<result.width;j++)result.set(j,i,result.at(j,i)*m);else if(m instanceof Matrix)if(m.height!==this.width||m.width!==this.height)console.error("[Error] Matrix::mult : matrices must have same transposed size.");else{result=new Matrix(this.height);for(let i=0;i<this.height;i++)for(let j=0;j<this.height;j++){let s=0;for(let k=0;k<this.width;k++)s+=this.at(k,i)*m.at(j,k);result.set(j,i,s)}}else console.error(`[Error] Matrix::mult : Matrix or number expected, got ${typeof matrixOrNumber}`);return result}transpose(onACopy=!1){const copy=new Matrix(this),me=this;onACopy&&([copy,me]=[me,copy]),me.properties.size=Object.freeze({x:me.properties.size.y,y:me.properties.size.x}),me.properties.array=[];for(let i=0;i<copy.width;i++){const row=[];for(let j=0;j<copy.height;j++)row.push(0);me.properties.array.push(row)}for(let i=0;i<copy.height;i++)for(let j=0;j<copy.width;j++)me.set(i,j,copy.at(j,i));return me}getColumn(x){if(x<0||x>this.width)return[];const column=[];for(let i=0;i<this.height;i++)column.push(this.at(x,i));return column}getRow(y){return y<0||y>this.height?[]:this.properties.array[y]}setColumn(x,column){if(x<0||x>this.width)return console.error("[Error] Matrix::setColumn : wrong index given.");if(column.length!==this.height)return console.error("[Error] Matrix::setColumn : column must have the same length as the matrix's height.");for(let i=0;i<this.height;i++)this.set(x,i,column[i]);return this}setRow(y,row){return y<0||y>this.height?console.error("[Error] Matrix::setRow : wrong index given."):row.length!==this.height?console.error("[Error] Matrix::setRow : row must have the same length as the matrix's width."):(this.properties.array[y]=row,this)}}export class Path{constructor(x=null,y=null){this.d=null,this.isClosed=!1,x&&y&&this.MoveTo(x,y)}clear(){this.d=null}draw(){null!==this.d?path(this.d+(this.isClosed?" Z":"")):console.error("Cannot draw it because you didn't make a path")}MoveTo(x,y){null===this.d?this.d=`M ${x} ${y}`:this.d+=` M ${x} ${y}`}moveTo(x,y){if(null===this.d)return console.error("You have to initialize the fist path's position");this.d+=` m ${x} ${y}`}LineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` L ${x} ${y}`}lineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` l ${x} ${y}`}Horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` H ${x}`}horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` h ${x}`}Vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` V ${y}`}vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` v ${y}`}Arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` A ${x} ${y} ${r} ${start} ${end} ${!0===antiClockwise?1:0}`}arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` a ${x} ${y} ${r} ${start} ${end} ${!0===antiClockwise?1:0}`}close(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!0}open(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!1}move(x,y=null){null===y&&x instanceof Vector&&([x,y]=[x.x,x.y]),null!==this.d&&(this.d=this.d.replace(/([MLHVA])\s([\d\.]+)(\s([\d\.]+))?/g,(c,p1,p2,p3)=>"H"===p1?`${p1} ${parseFloat(p2)+x}`:"V"===p1?`${p1} ${parseFloat(p2)+y}`:`${p1} ${parseFloat(p2)+x} ${parseFloat(p3)+y}`))}}const initializeAllEventHandlers=()=>{const t0=performance.now();MIN_DOC_SIZE=min(documentWidth(),documentHeight());const offset=elt=>{const rect=elt.getBoundingClientRect();return{top:rect.top+document.body.scrollTop,left:rect.left+document.body.scrollLeft}};canvas&&(canvas.addEventListener("mousemove",e=>{NOX_PV.oldMouseX=mouseX,NOX_PV.oldMouseY=mouseY,mouseX=e.clientX-offset(canvas).left,mouseY=e.clientY-offset(canvas).top,mouseDirection.x=e.movementX,mouseDirection.y=e.movementY,NOX_PV.callback("mousemove",e)}),canvas.addEventListener("touchstart",handleTouchStart,!1),canvas.addEventListener("touchmove",handleTouchMove,!1),canvas.addEventListener("mouseup",e=>{NOX_PV.isMouseDown=!1,NOX_PV.callback("mouseup",e)}),canvas.addEventListener("click",e=>NOX_PV.callback("click",e)),canvas.addEventListener("mouseenter",e=>NOX_PV.callback("mouseenter",e)),canvas.addEventListener("mouseleave",e=>NOX_PV.callback("mouseleave",e)),canvas.addEventListener("wheel",e=>NOX_PV.callback("wheel",e)),canvas.addEventListener("contextmenu",e=>NOX_PV.callback("contextmenu",e)),canvas.addEventListener("dblclick",e=>NOX_PV.callback("dblclick",e)),NOX_PV.swipePCEnable&&(canvas.addEventListener("mousedown",handleTouchStart,!1),canvas.addEventListener("mousemove",handleTouchMove,!1)),"function"==typeof onSwipe&&(canvas.addEventListener("swipeleft",()=>NOX_PV.callback("swipe","left"),!1),canvas.addEventListener("swiperight",()=>NOX_PV.callback("swipe","right"),!1),canvas.addEventListener("swipeup",()=>NOX_PV.callback("swipe","up"),!1),canvas.addEventListener("swipedown",()=>NOX_PV.callback("swipe","down"),!1))),window.addEventListener("keypress",e=>{NOX_PV.keys[e.code]=!0,NOX_PV.callback("keypress",e)}),window.addEventListener("keydown",e=>{NOX_PV.keys[e.code]=!0,NOX_PV.callback("keydown",e)}),window.addEventListener("keyup",e=>{NOX_PV.keys[e.code]=!1,NOX_PV.callback("keyup",e)}),window.addEventListener("resize",()=>{const newWidth=document.documentElement.clientWidth,newHeight=document.documentElement.clientHeight;MIN_DOC_SIZE=min(newWidth,newHeight),NOX_PV.callback("resize",{width:newWidth,height:newHeight})}),window.addEventListener("blur",()=>NOX_PV.callback("blur")),window.addEventListener("focus",()=>NOX_PV.callback("focus")),window.addEventListener("online",e=>NOX_PV.callback("online",e)),window.addEventListener("offline",e=>NOX_PV.callback("offline",e));const t1=performance.now();if(NOX_PV.logPerfs){const perfData={initHandlers:{ms:t1-t0}};console.info("Performances while initializing the canvas environment :"),console.table(perfData)}};export const listen=(event,callback)=>{NOX_PV.callbackListeners[event]=callback};export const stopListen=event=>{event in NOX_PV.callbackListeners&&delete NOX_PV.callbackListeners[event]};export const draw=drawFunction=>{"function"!=typeof drawFunction?console.error("The draw function must take an argument as type 'function'."):null!==NOX_PV.drawFunc?console.warn("You already declared your draw function."):(NOX_PV.drawFunc=drawFunction,"function"!=typeof NOX_PV.updateFunc&&drawLoop())};export const update=updateFunction=>{"function"!=typeof updateFunction?console.error("The update function must take an argument as type 'function'."):null!==NOX_PV.updateFunc?console.warn("You already declared your update function."):(NOX_PV.updateFunc=updateFunction,"function"!=typeof NOX_PV.drawFunc&&drawLoop())};export const logPerformances=()=>{NOX_PV.logPerfs=!0};const NOX_PV={hasInitAllEventHandlers:!1,updateFunc:null,drawFunc:null,notSetup:!0,logPerfs:!1,drawLoopInfo:{it:0,t0:0,t1:0,t2:0,freq:720},lut:[],bFill:!0,bStroke:!0,keys:{},isMouseDown:!1,oldMouseX:0,oldMouseY:0,isPointerLocked:!1,swipexDown:null,swipeyDown:null,swipePCEnable:!0,lastSwipe:null,bGuideLines:!1,fontSize:"12px",fontFamily:"Monospace",loop:!0,timer:0,now:0,then:Date.now(),firstThen:Date.now(),interval:1e3/fps,delta:0,counter:0,time_el:0,timer:new Time,colorTreatment:(...oColor)=>{const n=oColor.length;if(n>0&&(oColor[0]instanceof CanvasGradient||oColor[0]instanceof CanvasPattern))return oColor[0];if(1===n&&"number"==typeof oColor[0]){if(0<=(oColor=oColor[0])&&oColor<=255)return`rgb(${oColor}, ${oColor}, ${oColor})`}else{if(2===n&&oColor.every((c,i)=>"number"==typeof c&&0<=c&&c<=255||4===i&&0<=c&&c<=1))return`rgba(${oColor[0]}, ${oColor[0]}, ${oColor[0]}, ${oColor[1]>1?oColor[1]/255:oColor[1]})`;if([3,4].includes(n)&&oColor.every(c=>"number"==typeof c)){if(oColor.every((c,i)=>0<=c&&c<=255||4===i&&0<=c&&c<=1))return`rgb${4===n?"a":""}(${oColor[0]}, ${oColor[1]}, ${oColor[2]}${4===n?`, ${oColor[3]>1?oColor[3]/255:oColor[3]}`:""})`}else if(1===n&&"string"==typeof oColor[0]){const color=(oColor=oColor[0]).replace(/\s/gi,""),reg={hex:/^#([0-9a-z]{3}){1,2}$/i,rgb:/^rgba?\((\d{1,3},){2}\d{1,3}(,\d(\.\d+)?)?\)$/,hsl:/^hsl\(\d{1,3},\d{1,3}%,\d{1,3}%\)$/,name:/^\w{3,30}$/};for(let regex in reg)if(reg[regex].test(color))return oColor}else if(oColor[0]instanceof HEX||oColor[0]instanceof RGB||oColor[0]instanceof HSL)return oColor[0].toString()}return canvas?window.getComputedStyle(canvas).backgroundColor:"#000"},perlin:{lod:10,unit:1,gradient:[],seed:[],generateSeed:()=>Array(255).fill(0).map((i,j)=>j).sort(()=>Math.random()-.5),get:(x,y,lod=NOX_PV.perlin.lod,seed=NOX_PV.perlin.seed)=>{x/=lod,y/=lod;const[x0,y0]=[floor(x),floor(y)],[dx,dy,ii,jj]=[x-x0,y-y0,255&x0,255&y0],stuv=[];for(let i=0;i<4;i++)try{const v=seed[(ii+i%2+seed[jj+floor(i/2)])%255]%NOX_PV.perlin.gradient.length;stuv.push(NOX_PV.perlin.gradient[v][0]*(dx-i%2)+NOX_PV.perlin.gradient[v][1]*(dy-floor(i/2)))}catch(e){stuv.push(0)}const[Cx,Cy]=[3*dx*dx-2*dx*dx*dx,3*dy*dy-2*dy*dy*dy],[Li1,Li2]=[stuv[0]+Cx*(stuv[1]-stuv[0]),stuv[2]+Cx*(stuv[3]-stuv[2])];return map(Li1+Cy*(Li2-Li1),-NOX_PV.perlin.unit,NOX_PV.perlin.unit,0,1)}},easeElastic:(type,t,b,c,d)=>{if(0===t)return b;if(1==(t/=d))return b+c;const p=.3*d,s=p/(c<0?4:2*PI*asin(c/a)),x=sin(2*PI*(t*d-s)/p);return"in"===type?-a*pow(2,10*(t-=1))*x+b:"out"===type?a*pow(2,-10*t)*x+c+b:t<1?a*pow(2,10*(t-=1))*x*-.5+b:a*pow(2,-10*(t-=1))*x*.5+c+b},callbackListeners:{},callback:(event,e)=>{event in NOX_PV.callbackListeners&&NOX_PV.callbackListeners[event](e)}};NOX_PV.perlin.gradient=[[NOX_PV.perlin.unit,NOX_PV.perlin.unit],[-NOX_PV.perlin.unit,NOX_PV.perlin.unit],[NOX_PV.perlin.unit,-NOX_PV.perlin.unit],[-NOX_PV.perlin.unit,-NOX_PV.perlin.unit]];for(let i=0;i<256;i++)NOX_PV.lut[i]=(i<16?"0":"")+i.toString(16);NOX_PV.easeFuncMap={linear:easeLinear,quadIn:easeInQuad,quadOut:easeOutQuad,quadInOut:easeInOutQuad,sineIn:easeInSine,sineOut:easeOutSine,sineInOut:easeInOutSine,expoIn:easeInExpo,expoOut:easeOutExpo,expoInOut:easeInOutExpo,circIn:easeInCirc,circOut:easeOutCirc,circInOut:easeInOutCirc,cubicIn:easeInCubic,cubicOut:easeOutCubic,cubicInOut:easeInOutCubic,quartIn:easeInQuart,quartOut:easeOutQuart,quartInOut:easeInOutQuart,quintIn:easeInQuint,quintOut:easeOutQuint,quintInOut:easeInOutQuint,backIn:easeInBack,backOut:easeOutBack,backInOut:easeInOutBack,elasticIn:easeInElastic,elasticOut:easeOutElastic,elasticInOut:easeInOutElastic};