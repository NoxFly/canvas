/**
 * @copyright   Copyright (C) 2019 - 2022 Dorian Thivolle All rights reserved.
 * @license     GNU General Public License version 3 or later; see LICENSE.txt
 * @author		Dorian Thivolle
 * @name		canvas
 * @package		NoxFly/canvas
 * @see			https://github.com/NoxFly/canvas
 * @since		30 Dec 2019
 * @version		{1.6.0}
 */
export let ctx=null;export let canvas=null;export let width=0,height=0,realWidth=0,realHeight=0,mouseX=0,mouseY=0,fps=60;export let dragPoint=null;export var pixels=void 0;export const documentWidth=()=>document.documentElement.clientWidth;export const documentHeight=()=>document.documentElement.clientHeight;export let MIN_DOC_SIZE=Math.min(documentWidth(),documentHeight());export const PI=Math.PI;export const isDevice=Object.freeze({mobile:/iPhone|iPad|iPod|Android/i.test(navigator.userAgent),ios:/iPad|iPhone|iPod/.test(navigator.userAgent),android:/Android/.test(navigator.userAgent)});export const mouseDirection={x:0,y:0};export const moveTo=(x,y)=>ctx.moveTo(x-NOX_PV.cam.x,y-NOX_PV.cam.y);export const lineTo=(x,y)=>ctx.lineTo(x-NOX_PV.cam.x,y-NOX_PV.cam.y);export const arcTo=(x1,y1,x2,y2,r)=>ctx.arcTo(x1-NOX_PV.cam.x,y1-NOX_PV.cam.y,x2-NOX_PV.cam.x,y2-NOX_PV.cam.y,r);export const line=(x1,y1,x2,y2)=>{beginPath(),moveTo(x1,y1),lineTo(x2,y2),NOX_PV.bStroke&&ctx.stroke()};export const polyline=(...values)=>{if(values.length%2!=0)return console.error("The function polyline must take an even number of values");beginPath(),values.length>0&&moveTo(values[0],values[1]);for(let i=2;i<values.length;i+=2){const x=values[i],y=values[i+1];lineTo(x,y)}NOX_PV.bStroke&&ctx.stroke(),NOX_PV.bFill&&ctx.fill()};export const arc=(x,y,r,start,end,antiClockwise=!1)=>{beginPath(),ctx.arc(x-NOX_PV.cam.x,y-NOX_PV.cam.y,r,start,end,antiClockwise),closePath(),NOX_PV.bStroke&&ctx.stroke(),NOX_PV.bFill&&ctx.fill()};export const circle=(x,y,r)=>{arc(x,y,r,0,2*PI)};export const fillRect=(x,y,w,h)=>{ctx.fillRect(x-NOX_PV.cam.x,y-NOX_PV.cam.y,w,h)};export const strokeRect=(x,y,w,h)=>{ctx.strokeRect(x-NOX_PV.cam.x,y-NOX_PV.cam.y,w,h)};export const rect=(x,y,w,h)=>{ctx.rect(x-NOX_PV.cam.x,y-NOX_PV.cam.y,w,h),NOX_PV.bFill&&ctx.fill(),NOX_PV.bStroke&&ctx.stroke()};export const roundRect=(x=0,y=0,w=0,h=0,radius=0,radiusTR,radiusBR,radiusBL)=>{void 0===radiusTR&&(radiusTR=radius),void 0===radiusBR&&(radiusBR=radius),void 0===radiusBL&&(radiusBL=radius);const x1=x+(radius=min(max(0,radius),50)),y1=y,x2=x+w-(radiusTR=min(max(0,radiusTR),50)),y2=y,x3=x+w,y3=y+h-(radiusBR=min(max(0,radiusBR),50)),x4=x+(radiusBL=min(max(0,radiusBL),50)),y4=y+h,x5=x,y5=y+radius;beginPath(),moveTo(x1,y1),lineTo(x2,y2),arcTo(x2+radiusTR,y2,x2+radiusTR,y2+radiusTR,radiusTR),lineTo(x3,y3),arcTo(x3,y3+radiusBR,x3-radiusBR,y3+radiusBR,radiusBR),lineTo(x4,y4),arcTo(x4-radiusBL,y4,x,y4-radiusBL,radiusBL),lineTo(x5,y5),arcTo(x5,y5-radius,x1,y1,radius),closePath(),NOX_PV.bStroke&&ctx.stroke(),NOX_PV.bFill&&ctx.fill()};export const path=p=>{if(!(p=p.trim()).startsWith("M"))return;p=p.split(" ");let mode="M";const modes={M:{n:2,f:(x,y)=>moveTo(x,y)},L:{n:2,f:(x,y)=>lineTo(x,y)},H:{n:1,f:(x,y)=>lineTo(x,y)},V:{n:1,f:(y,x)=>lineTo(x,y)},A:{n:6,f:(x,y,r,start,end,antiClockwise)=>ctx.arc(x-NOX_PV.cam.x,y-NOX_PV.cam.y,r,radian(start),radian(end),1===antiClockwise)},Z:{n:0,f:()=>lineTo(parseFloat(p[1]),parseFloat(p[2]))}},reg=new RegExp(`^[${Object.keys(modes).join("")}]|(-?d+(.d+)?)$`,"i");if(0===p.filter(point=>reg.test(point)).length)return;if(p.length<3)return;const d=[],lastIdx=p.length-1;for(let i=0;i<p.length;i++){const point=p[i];if(/[a-z]/i.test(point)){if(mode=point,"Z"===mode){if(i!==lastIdx)return;d.push("Z")}if(["z"].includes(mode))return;const nArg=modes[mode.toUpperCase()].n;if(lastIdx-nArg<i)return;const lastPos={x:0,y:0};if(d.length>0){const prev=d[d.length-1],hv=["H","V"].indexOf(prev[0]);if(-1!==hv)lastPos.x=prev[1+hv],lastPos.y=prev[2-hv];else{const k=1;lastPos.x=prev[k],lastPos.y=prev[k+1]}}const arr=[mode.toUpperCase()],hv=["H","V"].indexOf(arr[0]);for(let j=0;j<nArg;j++){i++;const n=parseFloat(p[i]);if(isNaN(n))return;arr.push(n)}if(-1!==hv&&arr.push(lastPos[Object.keys(lastPos)[1-hv]]),"A"===arr[0]&&(arr[1]-=arr[3]),/[mlhva]/.test(mode)&&("v"===mode?arr[1]+=lastPos.y:"h"===mode?arr[1]+=lastPos.x:(arr[1]+=lastPos.x,arr[2]+=lastPos.y)),d.push(arr),"A"===arr[0]){const angle=radian(arr[5]),x=arr[1]+cos(angle)*arr[3];y=arr[2]+sin(angle)*arr[3],d.push(["M",x,y])}}}beginPath(),d.forEach(step=>{"string"==typeof step?modes[step].f():modes[step[0]].f(...step.slice(1))}),NOX_PV.bFill&&ctx.fill(),NOX_PV.bStroke&&ctx.stroke()};export const text=(txt,x=0,y=0)=>{if(/\n/.test(txt)){const size=parseInt(NOX_PV.fontSize.replace(/(\d+)(\w+)?/,"$1"));txt=txt.split("\n");for(let i=0;i<txt.length;i++)ctx.fillText(txt[i],x-NOX_PV.cam.x,y-NOX_PV.cam.y+i*size)}else ctx.fillText(txt,x-NOX_PV.cam.x,y-NOX_PV.cam.y)};export const setFont=(size,font)=>{ctx.font=`${size}px ${font}`,NOX_PV.fontSize=`${size}px`,NOX_PV.fontFamily=font};export const fontSize=size=>{ctx.font=`${size}px ${NOX_PV.fontFamily}`,NOX_PV.fontSize=`${size}px`};export const fontFamily=font=>{ctx.font=`${NOX_PV.fontSize} ${font}`,NOX_PV.fontFamily=font};export const alignText=alignment=>{ctx.textAlign=["left","right","center","start","end"].indexOf(alignment)>-1?alignment:"left"};export const bezierCurveTo=(cp1x,cp1y,cp2x,cp2y,x,y)=>{ctx.bezierCurveTo(cp1x-NOX_PV.cam.x,cp1y-NOX_PV.cam.y,cp2x-NOX_PV.cam.x,cp2y-NOX_PV.cam.y,x-NOX_PV.cam.x,y-NOX_PV.cam.y)};export const quadraticCurveTo=(cpx,cpy,x,y)=>{ctx.quadraticCurveTo(cpx-NOX_PV.cam.x,cpy-NOX_PV.cam.y,x-NOX_PV.cam.x,y-NOX_PV.cam.y)};export const push=()=>ctx.save();export const pop=()=>ctx.restore();export const translate=(x,y)=>ctx.translate(x,y);export const rotate=degree=>ctx.rotate(radian(degree));export const clip=(...args)=>ctx.clip(...args);export const scale=(x,y=x)=>ctx.scale(x,y);export const noFill=()=>{NOX_PV.bFill=!1};export const noStroke=()=>{NOX_PV.bStroke=!1};export const background=(...color)=>{canvas.style.backgroundColor=NOX_PV.colorTreatment(...color)};export const stroke=(...color)=>{ctx.strokeStyle=NOX_PV.colorTreatment(...color),NOX_PV.bStroke=!0};export const strokeWeight=weight=>{ctx.lineWidth=weight};export const linecap=style=>{ctx.lineCap=["butt","round","square"].indexOf(style)>-1?style:"butt"};export const fill=(...color)=>{ctx.fillStyle=NOX_PV.colorTreatment(...color),NOX_PV.bFill=!0};export const createLinearGradient=(x1,y1,x2,y2)=>ctx.createLinearGradient(x1,y1,x2,y2);export const makeLinearGradient=(x1,y1,x2,y2,...params)=>{if(params.length%2!=0)return console.error("you have to tell params by pair (offset, color). Odd number of arguments given.");const grad=createLinearGradient(x1,y1,x2,y2);for(let i=0;i<params.length;i+=2){const offset=params[i],color=NOX_PV.colorTreatment(params[i+1]);grad.addColorStop(offset,color)}return grad};export const clearRect=(x,y,w,h)=>ctx.clearRect(x-NOX_PV.cam.x,y-NOX_PV.cam.y,w,h);export const beginPath=()=>ctx.beginPath();export const closePath=()=>ctx.closePath();export const drawFocusIfNeeded=(elementOrPath2D,element=null)=>{elementOrPath2D instanceof Element?ctx.drawFocusIfNeeded(elementOrPath2D):ctx.drawFocusIfNeeded(elementOrPath2D,element)};export const setLineDash=array=>{if(!Array.isArray(array))return console.error("Array type expected. Got "+typeof array);ctx.setLineDash(array)};export const getLineDash=()=>ctx.getLineDash();export const globalAlpha=globalAlpha=>{ctx.globalAlpha=globalAlpha};export const globalCompositeOperation=type=>{ctx.globalCompositeOperation=type};export const setSmoothingQuality=quality=>{ctx.imageSmoothingQuality=quality};export const isPointInPath=function(x,y,fillRule="nonzero"){return ctx.isPointInPath(...arguments)};export const isPointInStroke=function(x,y){return ctx.isPointInStroke(...arguments)};export const getTransform=()=>ctx.getTransform();export const lineDashOffset=(value=0)=>{ctx.lineDashOffset=value};export const lineJoin=type=>{ctx.lineJoin=type};export const measureText=text=>ctx.measureText(text);export const resetTransform=()=>ctx.resetTransform();export const setTransform=(...transform)=>ctx.setTransform(...transform);export const createPattern=(image,repetition="repeat")=>{ctx.createPattern(image,repetition)};export const createImageData=function(widthOrImageData,height=null){return ctx.createImageData(...arguments)};export const putImageData=(imageData,dx,dy,dirtyX=null,dirtyY=null,dirtyWidth=null,dirtyHeight=null)=>{null===dirtyX?ctx.putImageData(imageData,dx,dy):ctx.putImageData(imageData,dx,dy,dirtyX,dirtyY,dirtyWidth,dirtyHeight)};export const getImageData=(sx,sy,sw,sh)=>ctx.getImageData(sx,sy,sw,sh);export const drawImage=(image,sx,sy,sWidth=null,sHeight=null,dx=null,dy=null,dWidth=null,dHeight=null)=>{null===sWidth?ctx.drawImage(image,sx-NOX_PV.cam.x,sy-NOX_PV.cam.y):null===dx?ctx.drawImage(image,sx-NOX_PV.cam.x,sy-NOX_PV.cam.y,sWidth,sHeight):ctx.drawImage(image,sx,sy,sWidth,sHeight,dx-NOX_PV.cam.x,dy-NOX_PV.cam.y,dWidth,dHeight)};export const radian=deg=>deg*(PI/180);export const degree=rad=>rad*(180/PI);export const angleToVector=angle=>new Vector(cos(angle),sin(angle));export const vectorToAngle=vec=>{const baseVector=new Vector(1,0);let angle=angleBetweenVectors(baseVector,vec);return vec.y>0&&(angle*=-1),angle%360};export const angleBetweenVectors=(a,b)=>{const ab=a.x*b.x+a.y*b.y+a.z*b.z,cosO=ab/(a.mag*b.mag),O=acos(cosO);return O};export const dist=(a,b)=>{let s=0;if(a.x&&b.x){const x=b.x-a.x;s+=x*x}if(a.y&&b.y){const y=b.y-a.y;s+=y*y}if(a.z&&b.z){const z=b.z-a.z;s+=z*z}return sqrt(s)};export const mag=(a,b)=>new Vector(b.x-a.x,b.y-a.y);export const map=(arrayOrValue,start1,end1,start2,end2)=>{const m=val=>(val-start1)*(end2-start2)/(end1-start1)+start2;return"number"==typeof arrayOrValue?m(arrayOrValue):arrayOrValue.map(val=>m(val))};export const pow=(n,p=2)=>Math.pow(n,p);export const abs=n=>n>=0?n:-n;export const sqrt=n=>Math.sqrt(n);export const min=(...values)=>Math.min(...values);export const max=(...values)=>Math.max(...values);export const clamp=(a,b,c)=>max(a,min(b,c));export const round=n=>Math.round(n);export const floor=n=>Math.floor(n);export const ceil=n=>Math.ceil(n);export const trunc=n=>Math.trunc(n);export const random=(iMin=null,iMax=0)=>null===iMin?Math.random():floor(random()*(max(iMin,iMax)-min(iMin,iMax)+1))+min(iMin,iMax);export const sin=x=>Math.sin(x);export const cos=x=>Math.cos(x);export const tan=x=>Math.tan(x);export const asin=x=>Math.asin(x);export const acos=x=>Math.acos(x);export const atan=x=>Math.atan(x);export const atan2=(x,y)=>Math.atan2(y,x);export const sinh=x=>Math.sinh(x);export const cosh=x=>Math.cosh(x);export const exp=x=>Math.exp(x);export const log=x=>Math.log(x);export const log10=x=>Math.log10(x);export const sum=(...values)=>values.reduce((a,b)=>a+b);export const mean=(...values)=>sum(...values)/values.length;export const median=(...values)=>{if(0===values.length)return 0;values.sort((a,b)=>a-b);const half=floor(values.length/2);return values.length%2?values[half]:(values[half-1]+values[half])/2};export const mode=(...values)=>values.reduce((a,b,i,arr)=>arr.filter(v=>v===a).length>=arr.filter(v=>v===b).length?a:b,null);export const variance=(...values)=>values.reduce((a,b)=>a+pow(b-mean(...values)),0);export const std=(...values)=>sqrt(variance(...values));export const easeLinear=(t,b,c,d)=>c*t/d+b;export const easeInQuad=(t,b,c,d)=>c*(t/=d)*t+b;export const easeOutQuad=(t,b,c,d)=>-c*(t/=d)*(t-2)+b;export const easeInOutQuad=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t+b:-c/2*(--t*(t-2)-1)+b;export const easeInSine=(t,b,c,d)=>-c*cos(t/d*(PI/2))+c+b;export const easeOutSine=(t,b,c,d)=>c*sin(t/d*(PI/2))+b;export const easeInOutSine=(t,b,c,d)=>-c/2*(cos(PI*t/d)-1)+b;export const easeInExpo=(t,b,c,d)=>0===t?b:c*pow(2,10*(t/d-1))+b;export const easeOutExpo=(t,b,c,d)=>t===d?b+c:c*(1-pow(2,-10*t/d))+b;export const easeInOutExpo=(t,b,c,d)=>0===t?b:t===d?b+c:(t/=d/2)<1?c/2*pow(2,10*(t-1))+b:c/2*(2-pow(2,-10*--t))+b;export const easeInCirc=(t,b,c,d)=>-c*(sqrt(1-(t/=d)*t)-1)+b;export const easeOutCirc=(t,b,c,d)=>c*sqrt(1-(t=t/d-1)*t)+b;export const easeInOutCirc=(t,b,c,d)=>(t/=d/2)<1?-c/2*(sqrt(1-t*t)-1)+b:c/2*(sqrt(1-(t-=2)*t)+1)+b;export const easeInCubic=(t,b,c,d)=>c*(t/=d)*t*t+b;export const easeOutCubic=(t,b,c,d)=>c*((t=t/d-1)*t*t+1)+b;export const easeInOutCubic=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t*t+b:c/2*((t-=2)*t*t+2)+b;export const easeInQuart=(t,b,c,d)=>c*(t/=d)*t*t*t+b;export const easeOutQuart=(t,b,c,d)=>-c*((t=t/d-1)*t*t*t-1)+b;export const easeInOutQuart=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t*t*t+b:-c/2*((t-=2)*t*t*t-2)+b;export const easeInQuint=(t,b,c,d)=>c*(t/=d)*t*t*t*t+b;export const easeOutQuint=(t,b,c,d)=>c*((t=t/d-1)*t*t*t*t+1)+b;export const easeInOutQuint=(t,b,c,d)=>(t/=d/2)<1?c/2*t*t*t*t*t+b:c/2*((t-=2)*t*t*t*t+2)+b;export const easeInBack=(t,b,c,d)=>c*(t/=d)*t*(2.7*t-1.7)+b;export const easeOutBack=(t,b,c,d)=>c*((t=t/d-1)*t*(2.7*t+1.7)+1)+b;export const easeInOutBack=(t,b,c,d)=>(t/=d/2)<1?c/2*(t*t*(3.5925*t-1.7))+b:c/2*((t-=2)*t*(3.5925*t+1.7)+2)+b;export const easeInElastic=(t,b,c,d)=>NOX_PV.easeElastic("in",t,b,c,d);export const easeOutElastic=(t,b,c,d)=>NOX_PV.easeElastic("out",t,b,c,d);export const easeInOutElastic=(t,b,c,d)=>NOX_PV.easeElastic("inout",t,b,c,d);export const lerp=(v,t,p)=>v instanceof Vector&&t instanceof Vector?(v.x=lerp(v.x,t.x,p),v.y=lerp(v.y,t.y,p),v):"number"==typeof v&&"number"==typeof t?v+(t-v)*p:0;export const frameRate=f=>{f>=0&&(NOX_PV.interval=1e3/f)};export const getSwipe=()=>NOX_PV.lastSwipe;export const getSecondsPassed=()=>NOX_PV.timer.asSeconds();export const getMSPassed=()=>NOX_PV.timer.asMilliseconds();export const isKeyDown=key=>NOX_PV.keys[key];export const isKeyUp=key=>!NOX_PV.keys[key];export const mouseDir=()=>NOX_PV.isPointerLocked?mouseDirection:mouseX>NOX_PV.oldMouseX&&mouseY>NOX_PV.oldMouseY?"BOTTOM_RIGHT":mouseX>NOX_PV.oldMouseX&&mouseY<NOX_PV.oldMouseY?"TOP_RIGHT":mouseX<NOX_PV.oldMouseX&&mouseY<NOX_PV.oldMouseY?"TOP_LEFT":mouseX<NOX_PV.oldMouseX&&mouseY>NOX_PV.oldMouseY?"BOTTOM_LEFT":mouseX>NOX_PV.oldMouseX&&mouseY===NOX_PV.oldMouseY?"RIGHT":mouseX===NOX_PV.oldMouseX&&mouseY>NOX_PV.oldMouseY?"DOWN":mouseX===NOX_PV.oldMouseX&&mouseY<NOX_PV.oldMouseY?"UP":mouseX<NOX_PV.oldMouseX&&mouseY===NOX_PV.oldMouseY?"LEFT":null;export const setCanvasSize=(newWidth,newHeight)=>{canvas&&ctx?(canvas.style.width=newWidth+"px",canvas.style.height=newHeight+"px",canvas.width=newWidth,canvas.height=newHeight,width=newWidth,height=newHeight,camera.anchorType===Camera.ANCHOR_CENTER&&camera.anchorPoint.set(width/2,height/2)):console.warn("No canvas created yet, so cannot apply changes for its size.")};export const setAutoResize=(enable,onceDone=!0)=>{NOX_PV.autoResize=enable?onceDone?2:1:0};export const createCanvas=(w=null,h=null,bg="#000",requestPointerLock=!1,container=document.body)=>{if(null==w&&null==h&&(w=documentWidth(),h=documentHeight()),!(w<=0||h<=0))return null!=canvas&&(canvas.remove(),canvas=null,ctx=null),canvas=document.createElement("canvas"),width=w,height=h,canvas.width=width,canvas.height=height,canvas.style.width=width+"px",canvas.style.height=height+"px",realWidth=width,realHeight=height,canvas.id="nox-canvas",canvas.style.background=NOX_PV.colorTreatment(bg),container.appendChild(canvas),requestPointerLock&&(document.addEventListener("pointerlockchange",()=>{document.pointerLockElement&&"nox-canvas"==document.pointerLockElement.id||(NOX_PV.isPointerLocked=!1)},!1),canvas.addEventListener("click",()=>{NOX_PV.isPointerLocked||(NOX_PV.isPointerLocked=!0,canvas.requestPointerLock())})),ctx=canvas.getContext("2d"),initializeAllEventHandlers(),canvas;console.warn("Canvas size must be higher than 0")};export const showGuideLines=bool=>{NOX_PV.bGuideLines="true"===`${bool}`};export const setDrawCondition=(condition=null)=>{condition&&(NOX_PV.drawCond=condition)};const drawLoop=()=>{!0===NOX_PV.loop&&requestAnimationFrame(drawLoop);const t0=performance.now();if(NOX_PV.logPerfs&&0===NOX_PV.drawLoopInfo.it&&(NOX_PV.drawLoopInfo.start=t0),NOX_PV.now=Date.now(),NOX_PV.delta=NOX_PV.now-NOX_PV.then,camera.following)camera.position.set(camera.followPoint.x,camera.followPoint.y);else if(camera.moving){const m=NOX_PV.camera.move,t=m.start.asMilliseconds(),x=easeInOutQuad(t,m.from.x,m.length.x,m.duration),y=easeInOutQuad(t,m.from.y,m.length.y,m.duration);t>=m.duration?(camera.position.set(m.from.x+m.length.x,m.from.y+m.length.y),NOX_PV.camera.move=null):camera.position.set(x,y)}for(const module of NOX_PV.updateModules)module.update();if(NOX_PV.updateFunc(),NOX_PV.logPerfs&&(NOX_PV.drawLoopInfo.t1+=performance.now()-t0),NOX_PV.delta>NOX_PV.interval&&(NOX_PV.then=NOX_PV.now-NOX_PV.delta%NOX_PV.interval,NOX_PV.then-NOX_PV.firstThen>99999&&(NOX_PV.firstThen=NOX_PV.now,NOX_PV.then=NOX_PV.firstThen,NOX_PV.counter=0),NOX_PV.time_el=(NOX_PV.then-NOX_PV.firstThen)/1e3||1,NOX_PV.counter++,fps=round(NOX_PV.counter/NOX_PV.time_el),ctx&&NOX_PV.drawCond())){const t=performance.now();push(),clearRect(NOX_PV.cam.x,NOX_PV.cam.y,width,height);for(const module of NOX_PV.renderingModules)module.render();NOX_PV.drawFunc(),NOX_PV.bGuideLines&&(push(),fill("#46eaea"),stroke("#46eaea"),strokeWeight(1),line(0,mouseY,width,mouseY),line(mouseX,0,mouseX,height),text(`${floor(mouseX)}, ${floor(mouseY)}`,mouseX+5,mouseY-5),pop()),pop(),NOX_PV.drawLoopInfo.t2+=performance.now()-t}if(NOX_PV.logPerfs&&(NOX_PV.drawLoopInfo.it=(NOX_PV.drawLoopInfo.it+1)%NOX_PV.drawLoopInfo.freq,0===NOX_PV.drawLoopInfo.it)){NOX_PV.drawLoopInfo.t1/=NOX_PV.drawLoopInfo.freq,NOX_PV.drawLoopInfo.t2/=NOX_PV.drawLoopInfo.freq;const t1=floor(100*NOX_PV.drawLoopInfo.t1)/100,t2=floor(100*NOX_PV.drawLoopInfo.t2)/100,t3=floor(100*(t1+t2))/100;NOX_PV.drawLoopInfo.t1=0,NOX_PV.drawLoopInfo.t2=0;const data={update:{ms:t1},draw:{ms:t2},total:{ms:t3}};console.table(data)}};export const noLoop=()=>{NOX_PV.loop=!1};export const enableSmoothing=()=>{ctx&&(ctx.imageSmoothingEnabled=!0)};export const disableSmoothing=()=>{ctx&&(ctx.imageSmoothingEnabled=!1)};export const disableCamera=()=>{NOX_PV.camera.enabled=!1,NOX_PV.cam=NOX_PV.camera.hud};export const enableCamera=()=>{NOX_PV.camera.enabled=!0,NOX_PV.cam=camera};export const loadPixels=()=>{if(ctx instanceof CanvasRenderingContext2D&&canvas instanceof HTMLCanvasElement){NOX_PV.pixels=ctx.createImageData(canvas.width,canvas.height),pixels=NOX_PV.pixels.data;for(let i=0;i<width*height;i++)pixels[4*i+3]=255}else console.warn("Can't load canvas's pixels : no existing context found.")};export const updatePixels=()=>{void 0!==pixels&&ctx instanceof CanvasRenderingContext2D&&(NOX_PV.pixels.data=pixels,ctx.putImageData(NOX_PV.pixels,0,0))};export const perlin=(x,y=0)=>(NOX_PV.perlin.seed&&0!==NOX_PV.perlin.seed.length||(NOX_PV.perlin.seed=NOX_PV.perlin.generateSeed()),NOX_PV.perlin.get(x,y));export const noiseDetails=detailLevel=>{"number"==typeof detailLevel&&(NOX_PV.perlin.lod=detailLevel)};export const generateUUID=()=>{const d0=4294967295*Math.random()|0,d1=4294967295*Math.random()|0,d2=4294967295*Math.random()|0,d3=4294967295*Math.random()|0;return NOX_PV.lut[255&d0]+NOX_PV.lut[d0>>8&255]+NOX_PV.lut[d0>>16&255]+NOX_PV.lut[d0>>24&255]+"-"+NOX_PV.lut[255&d1]+NOX_PV.lut[d1>>8&255]+"-"+NOX_PV.lut[d1>>16&15|64]+NOX_PV.lut[d1>>24&255]+"-"+NOX_PV.lut[63&d2|128]+NOX_PV.lut[d2>>8&255]+"-"+NOX_PV.lut[d2>>16&255]+NOX_PV.lut[d2>>24&255]+NOX_PV.lut[255&d3]+NOX_PV.lut[d3>>8&255]+NOX_PV.lut[d3>>16&255]+NOX_PV.lut[d3>>24&255]};export class RGB{constructor(r,g=null,b=null,a=255){this.color={r:0,g:0,b:0},void 0===r&&(r=0),null!==g&&null===b&&(a=g,g=b=r),null===g&&(g=r,b=r),this.r=r,this.g=g,this.b=b,this.a=a}valueInInterval(val){return val<0||val>255?(console.error(`Color interval [0 - 255] no repespected (${val} given)`),min(max(val,0),255)):val}get r(){return this.color.r}get g(){return this.color.g}get b(){return this.color.b}get a(){return this.color.a}set r(val){this.color.r=this.valueInInterval(val)}set g(val){this.color.g=this.valueInInterval(val)}set b(val){this.color.b=this.valueInInterval(val)}set a(val){this.color.a=this.valueInInterval(val)}set(r,g,b,a=null){this.r=r,this.g=g,this.b=b,null!==a&&(this.a=a)}toString(){return`rgb${255!=this.a?"a":""}(${this.r}, ${this.g}, ${this.b}${255!=this.a?`, ${round(this.a/255*10)/10}`:""})`}intVal(){return[this.r,this.g,this.b,this.a]}toHEX(){let r=Number(this.r).toString()(16);r.length<2&&(r="0"+r);let g=Number(this.g).toString()(16);g.length<2&&(g="0"+g);let b=Number(this.b).toString()(16);b.length<2&&(b="0"+b);const rgb="#"+r+g+b;return new HEX(rgb)}toHSL(){const r=this.r/255,g=this.g/255,b=this.b/255,imax=max(r,g,b),imin=min(r,g,b);let h,s,l=(imax+imin)/2;if(imax===imin)h=s=0;else{const d=imax-imin;switch(s=l>.5?d/(2-imax-imin):d/(imax+imin),imax){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4}h/=6}return new HSL(round(10*h)/10,round(10*s)/10,round(10*l)/10)}}export class HEX{constructor(hexaColor){this.color={int:0,str:"#000000"},this.set(hexaColor)}toString(){return this.color.str}intVal(){return this.color.int}set(hexaColor){if("number"==typeof hexaColor){this.color.int=hexaColor;const h=hexaColor.toString()(16)+"";this.color.str="#"+(4===h.length?"00":"")+h}else"string"==typeof hexaColor&&/^#?([0-9a-f]{3}){1,2}$/i.test(hexaColor)?(3===(hexaColor=hexaColor.replace("#","")).length&&(hexaColor=hexaColor[0].repeat(2)+hexaColor[1].repeat(2)+hexaColor[2].repeat(2)),this.color.str="#"+hexaColor,this.color.int=parseInt(hexaColor,16)):console.error(`Given parameter isn't a recognized hexadecimal number: ${hexaColor}`)}toRGB(){const r=(16711680&this.intVal())>>>16,g=(65280&this.intVal())>>>8,b=255&this.intVal();return new RGB(r,g,b)}toHSL(){return this.toRGB().toHSL()}}export class HSL{constructor(hue,saturation=.5,light=.5){this.color={h:0,s:0,l:0},"number"!=typeof hue&&(console.error(`Hue given parameter isn't a recognized number value: ${hue}`),hue=0),this.h=hue,this.s=saturation,this.l=light}get h(){return this.color.h}get s(){return this.color.s}get l(){return this.color.l}set h(hue){this.color.h=hue>=0?hue%360:360-abs(hue)%360}set s(saturation){this.color.s=min(max(saturation,0),1)}set l(luminosity){this.color.l=min(max(luminosity,0),1)}add(hueToAdd){this.h=this.h+hueToAdd}sub(hueToSub){this.h=this.h-hueToSub}lighten(lightToAdd){this.l=this.l+lightToAdd}obscure(lightToSub){this.l=this.l-lightToSub}addSat(saturationToAdd){this.s=this.s+saturationToAdd}subSat(saturationToSub){this.s=this.s-saturationToSub}toString(){return`hsl(${this.h}, ${100*this.s}%, ${100*this.l}%)`}intVal(){return this.toHEX().intVal()}toHEX(){return this.toRGB().toHEX()}toRGB(){const C=(1-abs(2*this.l-1))*this.s,hh=this.h/60,X=C*(1-abs(hh%2-1));let r,g,b;r=g=b=0,hh>=0&&hh<1?[r,g]=[C,X]:hh>=1&&hh<2?[r,g]=[X,C]:hh>=2&&hh<3?[g,b]=[C,X]:hh>=3&&hh<4?[g,b]=[X,C]:[r,b]=hh>=4&&hh<5?[X,C]:[C,X];const m=this.l-C/2;return r=round(255*(r+m)),g=round(255*(g+m)),b=round(255*(b+m)),new RGB(r,g,b)}}export class PerlinNoise{static mapnumberTypes=["default","rgb","hsl"];static getMapnumberTypeIndex=typeStr=>PerlinNoise.mapnumberTypes.indexOf(typeStr.toLowerCase());constructor(lod=10,x=0,y=0,w=width,h=height,mapnumber="default"){this.lod=lod,this.seed=NOX_PV.perlin.generateSeed(),this.start={x:x,y:y},this.size={width:w,height:h},this.array=[],this.numberMapStyle=PerlinNoise.getMapnumberTypeIndex(mapnumber),this.calculate()}setLOD(lod){const tmp=this.lod;this.lod=lod,tmp!==lod&&this.calculate()}regenerateSeed(){this.seed=NOX_PV.perlin.generateSeed(),this.calculate()}setMapNumber(mapnumber){if(mapnumber=PerlinNoise.getMapnumberTypeIndex(mapnumber),this.numberMapStyle===mapnumber)return;let Lmin=0,Lmax=NOX_PV.perlin.unit,Rmin=0,Rmax=NOX_PV.perlin.unit;this.numberMapStyle>0&&([Lmin,Lmax]=[0,1===this.numberMapStyle?255:360]),this.numberMapStyle=mapnumber,this.numberMapStyle>0&&([Rmin,Rmax]=[0,1===this.numberMapStyle?255:360]),this.array.forEach((row,i)=>{this.array[i]=map(this.array[i],Lmin,Lmax,Rmin,Rmax)})}calculate(){this.array=[];for(let y=this.start.y;y<this.start.y+this.size.height;y++){const row=[];for(let x=this.start.x;x<this.start.x+this.size.width;x++)row.push(NOX_PV.perlin.get(x,y,this.lod,this.seed));this.array.push(row)}this.numberMapStyle>0&&this.setMapNumber(PerlinNoise.mapnumberTypes[this.numberMapStyle])}}export class Time{static units={nano:ms=>1e8*ms,micro:ms=>1e3*ms,milli:(t,unit="milli")=>{switch(unit){case"nano":return t/1e8;case"micro":return t/1e3;case"seconds":return 1e3*t;case"minutes":return 6e4*t;default:return t}},seconds:ms=>ms/1e3,minutes:ms=>ms/6e4};constructor(startingTime,unity="milli"){void 0!==startingTime&&Object.keys(Time.units).includes(unity)?(this.start=Time.units.milli(startingTime,unity),this.staticTime=!0):(this.reset(),this.staticTime=!1)}asNanoseconds(){return Time.units.nano(this.asMilliseconds())}asMicroseconds(){return Time.units.micro(this.asMilliseconds())}asMilliseconds(){return Time.units.milli(this.staticTime?this.start:Date.now()-this.start)}asSeconds(){return Time.units.seconds(this.asMilliseconds())}asMinutes(){return Time.units.minutes(this.asMilliseconds())}reset(){this.start=Date.now()}}export class Vector{constructor(x,y=null,z=null){let dimension=1;this.coords={x:0,y:0,z:0};const tmp={x:0,y:0,z:0};x instanceof Vector?(dimension=x.dimension,tmp.x=x.x,tmp.y=x.y,tmp.z=x.z):(dimension=Array.from(arguments).filter(a=>"number"==typeof a).length,tmp.x=x,tmp.y=y,tmp.z=z),this.constants=Object.freeze({dimension:dimension}),this.set(tmp.x,tmp.y,tmp.z)}get dimension(){return this.constants.dimension}get x(){return this.coords.x}get y(){return this.coords.y}get z(){return this.coords.z}set x(x){this.coords.x=x}set y(y){this.dimension>1?this.coords.y=y:console.error("Cannot modify the Y of a 1D vector")}set z(z){this.dimension>2?this.coords.z=z:console.error(`Cannot modify the Y of a ${this.dimension}D vector`)}copy(){return new Vector(this)}normalize(apply=!1){const norm=Math.hypot(this.x,this.y,this.z);return apply?(0!==norm&&(this.x=this.x/norm,this.dimension>1&&(this.y=this.y/norm,3===this.dimension&&(this.z=this.z/norm))),this):new Vector(this).normalize(!0)}set(x,y=null,z=null){if(x instanceof Vector)this.x=x.x,2===this.dimension&&(this.y=x.y),3===this.dimension&&(this.z=x.z);else{if("number"!=typeof x)return console.error("[Error] Vector::set : x parameter must be a number or a Vector");if(this.dimension>1){if(null!==y&&"number"!=typeof y)return console.error("[Error] Vector::set : y parameter must be a number");if(null!==z&&this.dimension>2&&"number"!=typeof z)return console.error("[Error] Vector::set : z parameter must be a number")}this.x=x,this.dimension>1&&(null!==y&&(this.y=y),3===this.dimension&&null!=z&&(this.z=z))}return this}add(x,y=null,z=null){return x instanceof Vector?this.set(this.x+x.x,this.y+x.y,this.z+x.z):(null===y&&(y=x),null===z&&(z=x),this.set(this.x+x,this.y+y,this.z+z))}sub(x,y=null,z=null){return x instanceof Vector?this.set(this.x-x.x,this.y-x.y,this.z-x.z):(null===y&&(y=x),null===z&&(z=x),this.set(this.x-x,this.y-y,this.z-z))}mult(x,y=null,z=null){return x instanceof Vector?this.set(this.x*x.x,this.y*x.y,this.z*x.z):(null===y&&(y=x),null===z&&(z=x),this.set(this.x*x,this.y*y,this.z*z))}div(x,y=null,z=null){return x instanceof Vector?this.set(this.x/x.x,this.y/x.y,this.z/x.z):(null===y&&(y=x),null===z&&(z=x),this.set(this.x/x,this.y/y,this.z/z))}invert(antiClockwise=!1){return this.dimension>1&&(2===this.dimension?[this.x,this.y]=[this.y,this.x]:[this.x,this.y,this.z]=antiClockwise?[this.y,this.z,this.x]:[this.z,this.x,this.y]),this}get mag(){return Math.hypot(this.x,this.y,this.z)}setMag(newMag){return this.x=this.x*newMag/this.mag,this.dimension>1&&(this.y=this.y*newMag/this.mag),this.dimension>2&&(this.z=this.z*newMag/this.mag),this}toString(){return`{ x: ${this.x}${this.dimension>1?`, y: ${this.y}`:""}${this.dimension>2?`, z: ${this.z}`:""} }`}array(){const arr=[this.x];return this.dimension>1&&arr.push(this.y),this.dimension>2&&arr.push(this.z),arr}object(){const o={x:this.x};return this.dimension>1&&(o.y=this.y,this.dimension>2&&(o.z=this.z)),o}bow(x,y,style={}){if(3===this.dimension)return;style.strokeWeight?strokeWeight(style.strokeWeight):strokeWeight(1),style.stroke?stroke(style.stroke):stroke("#fff");const rotation=degree(vectorToAngle(this));push(),translate(x,y),line(0,0,this.x,this.y),linecap("round"),push(),translate(this.x,this.y),push(),rotate(rotation+25),line(0,0,-min(this.mag/2.5,10),0),rotate(-50),line(0,0,-min(this.mag/2.5,10),0),pop(),pop(),pop()}}export class Matrix{properties={array:[],width:0,height:0};constructor(...args){if(args.length>0)if(args[0]instanceof Matrix){this.properties.width=args[0].width,this.properties.height=args[0].height;for(let i=0;i<args[0].height;i++){const row=[];for(let j=0;j<args[0].width;j++)row.push(args[0].at(j,i));this.properties.array.push(row)}}else if("number"==typeof args[0]){let fill=0;const w=args[0];let h=w;args.length>1&&"number"==typeof args[1]&&(h=args[1],args.length>2&&"number"==typeof args[2]&&(fill=args[2]));for(let i=0;i<h;i++){const row=[];for(let j=0;j<w;j++)row.push(fill);this.properties.array.push(row)}this.properties.width=w,this.properties.height=h}else 1===args.length&&Array.isArray(args[0])&&args[0].every(a=>Array.isArray(a)&&a.length===args[0][0].length&&a.every(e=>"number"==typeof e))?(this.properties.array=args[0],args[0].length>0&&(this.properties.width=args[0][0].length),this.properties.height=args[0].length):args.every(a=>Array.isArray(a)&&a.length===args[0].length&&a.every(e=>"number"==typeof e))?(this.properties.array=args,this.properties.width=args[0].length,this.properties.height=args.length):console.error("[Error] Matrix constructor : Unrecognized parameters.");this.properties.size=Object.freeze({x:this.properties.width,y:this.properties.height}),delete this.properties.width,delete this.properties.height}get array(){return this.properties.array}get array1D(){return this.array.reduce((a,b)=>[...a,...b],[])}get width(){return this.properties.size.x}get height(){return this.properties.size.y}get dimension(){return this.properties.size}toString(uncluttered=!1){const sep=this.height>0?"\n":"",brackets_open=uncluttered?"":"[",brackets_close=uncluttered?"":"]",m=uncluttered?max(...this.array.map(a=>max(...a.map(e=>e.toString()().length)))):0,_format=uncluttered?arr=>arr.map(e=>" ".repeat(6+m-2*e.toString()().length)+e).join(" "):arr=>arr.join(", ");return brackets_open+sep+this.properties.array.map(a=>"\t"+brackets_open+_format(a)+brackets_close).join("\n")+sep+brackets_close}at(x,y){return"number"==typeof x&&"number"==typeof y&&x>-1&&y>-1&&x<this.width&&y<this.height?this.array[y][x]:null}set(x,y,value){null!==this.at(x,y)&&"number"==typeof value&&(this.array[y][x]=value)}equals(matrix){if(matrix.width!==this.width||matrix.height!==this.height)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++)if(matrix.at(j,i)!==this.at(j,i))return!1;return!0}get isSymmetrical(){for(let i=0;i<this.width;i++)for(let j=0;j<this.height;j++)if(this.at(i,j)!==this.at(j,i))return!1;return!0}get isSquare(){return this.width===this.height}get isIdentity(){return this.isSquare&&this.array.every((arr,i)=>arr.every((e,j)=>i===j&&1===e||i!==j&&0===e))}get isDiagonal(){return this.isSquare&&this.array.every((arr,i)=>arr.every((e,j)=>i===j&&0!==e||i!==j&&0===e))}get isTriangular(){const a=this.isLowerTri,b=this.isUpperTri;return a?!b:b}get isLowerTri(){if(!this.isSquare)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++){const e=this.at(j,i);if(j>=i&&0!==e)return!1}return!0}get isUpperTri(){if(!this.isSquare)return!1;for(let i=0;i<this.height;i++)for(let j=0;j<this.width;j++){const e=this.at(j,i);if(j<=i&&0!==e)return!1}return!0}get diagonal(){return this.isSquare?this.array.map((arr,i)=>arr[i]):[]}get det(){if(!this.isSquare)return 0;if(this.isIdentity)return 1;if(this.isDiagonal||this.isTriangular){const diag=this.diagonal;return diag.reduce((acc,curr)=>acc*curr,1)}if(2===this.width)return this.at(0,0)*this.at(1,1)-this.at(1,0)*this.at(0,1);if(3===this.width){const[a,b,c,d,e,f,g,h,i]=this.array1D;return a*e*i+d*h*c+b*f*g-(g*e*c+d*b*i+a*h*f)}{const det=m=>1===m.length?m[0][0]:2===m.length?m[0][0]*m[1][1]-m[0][1]*m[1][0]:m[0].reduce((r,e,i)=>r+(-1)**(i+2)*e*det(m.slice(1).map(c=>c.filter((_,j)=>i!=j))),0);return det(this.array)}}add(matrix,onACopy=!1){if("op"in this||(this.op=(a,b)=>a+b),!(matrix instanceof Matrix)&&"number"!=typeof matrix)return console.error(`[Error] Matrix::add : Matrix expected, ${typeof matrix} given`),delete this.op,this;if(matrix instanceof Matrix&&(matrix.width!==this.width||matrix.height!==this.height))return console.error("[Error] Matrix::add : Cannot operate an addition between 2 matrices with different dimensions."),delete this.op,this;const result=onACopy?new Matrix(this):this,b=matrix instanceof Matrix;for(let i=0;i<result.height;i++)for(let j=0;j<result.width;j++)result.set(j,i,this.op(result.at(j,i),b?matrix.at(j,i):matrix));return delete this.op,result}sub(matrix,onACopy=!1){return this.op=(a,b)=>a-b,this.add(matrix,onACopy)}mult(matrixOrnumber,onACopy=!1){const m=matrixOrnumber;let result=onACopy?new Matrix(this):this;if("number"==typeof m)for(let i=0;i<result.height;i++)for(let j=0;j<result.width;j++)result.set(j,i,result.at(j,i)*m);else if(m instanceof Matrix)if(m.height!==this.width||m.width!==this.height)console.error("[Error] Matrix::mult : matrices must have same transposed size.");else{result=new Matrix(this.height);for(let i=0;i<this.height;i++)for(let j=0;j<this.height;j++){let s=0;for(let k=0;k<this.width;k++)s+=this.at(k,i)*m.at(j,k);result.set(j,i,s)}}else console.error(`[Error] Matrix::mult : Matrix or number expected, got ${typeof matrixOrnumber}`);return result}transpose(onACopy=!1){let copy=new Matrix(this),me=this;onACopy&&([copy,me]=[me,copy]),me.properties.size=Object.freeze({x:me.properties.size.y,y:me.properties.size.x}),me.properties.array=[];for(let i=0;i<copy.width;i++){const row=[];for(let j=0;j<copy.height;j++)row.push(0);me.properties.array.push(row)}for(let i=0;i<copy.height;i++)for(let j=0;j<copy.width;j++)me.set(i,j,copy.at(j,i));return me}getColumn(x){if(x<0||x>this.width)return[];const column=[];for(let i=0;i<this.height;i++)column.push(this.at(x,i));return column}getRow(y){return y<0||y>this.height?[]:this.properties.array[y]}setColumn(x,column){if(x<0||x>this.width)return console.error("[Error] Matrix::setColumn : wrong index given.");if(column.length!==this.height)return console.error("[Error] Matrix::setColumn : column must have the same length as the matrix's height.");for(let i=0;i<this.height;i++)this.set(x,i,column[i]);return this}setRow(y,row){return y<0||y>this.height?console.error("[Error] Matrix::setRow : wrong index given."):row.length!==this.height?console.error("[Error] Matrix::setRow : row must have the same length as the matrix's width."):(this.properties.array[y]=row,this)}}export class Camera{static ANCHOR_DEFAULT=0;static ANCHOR_CENTER=1;uuid=generateUUID();position=new Vector(0,0);anchorType=Camera.ANCHOR_DEFAULT;anchorPoint=new Vector(0,0);followPoint=null;constructor(position=null){position instanceof Vector&&(this.position=position)}get x(){return this.position.x-this.anchorPoint.x}get y(){return this.position.y-this.anchorPoint.y}get following(){return null!==this.followPoint}get moving(){return null!==NOX_PV.camera.move}setAnchor(anchor){return anchor===Camera.ANCHOR_DEFAULT?(this.anchorPoint.set(0,0),this.anchorType=anchor):anchor===Camera.ANCHOR_CENTER&&(this.anchorPoint.set(width/2,height/2),this.anchorType=anchor),this}setMoveType(moveType){return moveType in Object.keys(NOX_PV.easeFuncMap)&&(this.moveType=moveType),this}follow(point){return point instanceof Vector?this.followPoint=point:"object"==typeof point&&point.position instanceof Vector?this.followPoint=point.position:console.error("[Error] Camera::follow : parameter should be a Vector."),this}stopFollow(){return this.followPoint=null,this}move(x,y,duration=1e3){if(this.moving)return;this.following&&this.stopFollow();const length=new Vector(0,0);return x instanceof Vector?(length.set(x),duration=y||1e3):length.set(x,y),length.sub(this.anchorPoint),NOX_PV.camera.move={from:this.position.copy(),length:length,duration:duration,start:new Time},this}moveTo(x,y,duration=1e3){const v=new Vector(0,0);return x instanceof Vector?(v.set(x.x,x.y),duration=y):v.set(x,y),v.sub(this.position).add(this.anchorPoint),this.move(v.x,v.y,duration),this}stop(){return NOX_PV.camera.move=null,this}}export class Path{constructor(x=null,y=null){this.d=null,this.isClosed=!1,x&&y&&this.MoveTo(x,y)}clear(){this.d=null}draw(){null!==this.d?path(this.d+(this.isClosed?" Z":"")):console.error("Cannot draw it because you didn't make a path")}MoveTo(x,y){null===this.d?this.d=`M ${x} ${y}`:this.d+=` M ${x} ${y}`}moveTo(x,y){if(null===this.d)return console.error("You have to initialize the fist path's position");this.d+=` m ${x} ${y}`}LineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` L ${x} ${y}`}lineTo(x,y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` l ${x} ${y}`}Horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` H ${x}`}horizontal(x){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` h ${x}`}Vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` V ${y}`}vertical(y){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` v ${y}`}Arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` A ${x} ${y} ${r} ${start} ${end} ${!0===antiClockwise?1:0}`}arc(x,y,r,start,end,antiClockwise=!1){if(null===this.d)return console.error("You have to initialize the first path's position");this.d+=` a ${x} ${y} ${r} ${start} ${end} ${!0===antiClockwise?1:0}`}close(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!0}open(){if(null===this.d)return console.error("You have to initialize the first path's position");this.isClosed=!1}move(x,y=null){null===y&&x instanceof Vector&&([x,y]=[x.x,x.y]),null!==this.d&&(this.d=this.d.replace(/([MLHVA])\s([\d\.]+)(\s([\d\.]+))?/g,(c,p1,p2,p3)=>"H"===p1?`${p1} ${parseFloat(p2)+x}`:"V"===p1?`${p1} ${parseFloat(p2)+y}`:`${p1} ${parseFloat(p2)+x} ${parseFloat(p3)+y}`))}}export class Quadtree{static Point=class Point{constructor(x,y,dataPtr){this.x=x,this.y=y,this.dataPtr=dataPtr}};static Rectangle=class Rectangle{constructor(x,y,w,h){this.x=x,this.y=y,this.w=w,this.h=h}contains(point){return this.x<=point.x&&point.x<=this.x+this.w&&this.y<=point.y&&point.y<=this.y+this.h}intersect(rectangle){return!(rectangle.x>this.x+this.w||rectangle.x+rectangle.w<this.x||rectangle.y>this.y+this.h||rectangle.y+rectangle.h<this.y)}wrap(rectangle){return this.x<=rectangle.x&&rectangle.x+rectangle.w<=this.x+this.w&&this.y<=rectangle.y&&rectangle.y+rectangle.h<=this.y+this.h}};constructor(boundary,capacity=5){this.boundary=boundary,this.capacity=capacity,this.points=[],this.divided=!1}clear(){this.points=[],this.divided=!1,delete this.northeast,delete this.northwest,delete this.southeast,delete this.southwest}get children(){return this.divided?[this.northwest,this.northeast,this.southwest,this.southeast]:[]}subdivide(){if(!this.divided){const{x:x,y:y,w:w,h:h}=this.boundary,ne=new Quadtree.Rectangle(x+w/2,y,w/2,h/2),nw=new Quadtree.Rectangle(x,y,w/2,h/2),se=new Quadtree.Rectangle(x+w/2,y+h/2,w/2,h/2),sw=new Quadtree.Rectangle(x,y+h/2,w/2,h/2);this.northwest=new Quadtree(nw),this.northeast=new Quadtree(ne),this.southwest=new Quadtree(sw),this.southeast=new Quadtree(se),this.divided=!0;for(const p of this.points)this.insert(p);this.points=[]}}insert(point){return!!this.boundary.contains(point)&&(this.divided?this.northeast.insert(point)||this.northwest.insert(point)||this.southeast.insert(point)||this.southwest.insert(point):this.points.length<this.capacity?(this.points.push(point),!0):(this.subdivide(),void this.insert(point)))}query(range){if(!this.divided){if(range.wrap(this.boundary))return this.points;if(range.intersect(this.boundary)){const found=[];for(const p of this.points)range.contains(p)&&found.push(p);return found}return[]}if(range.wrap(this.boundary))return this.getAllPoints();const found=[];return found.push(...this.northwest.query(range)),found.push(...this.northeast.query(range)),found.push(...this.southwest.query(range)),found.push(...this.southeast.query(range)),found}show(color=20){noFill(),stroke(color),strokeWeight(1),strokeRect(this.boundary.x,this.boundary.y,this.boundary.w-1,this.boundary.h-1),this.divided&&(this.northeast.show(),this.northwest.show(),this.southeast.show(),this.southwest.show())}getAllPoints(){if(!this.divided)return this.points;const points=[];for(const region of this.children)points.push(...region.getAllPoints());return points}size(){let n=this.points.length;for(const region of this.children)n+=region.size();return n}}export const listen=(event,callback)=>{NOX_PV.callbackListeners[event]=callback};export const stopListen=event=>{event in NOX_PV.callbackListeners&&delete NOX_PV.callbackListeners[event]};export const draw=drawFunction=>{"function"!=typeof drawFunction?console.error("The draw function must take an argument as type 'function'."):null!==NOX_PV.drawFunc?console.warn("You already declared your draw function."):(NOX_PV.drawFunc=drawFunction,"function"!=typeof NOX_PV.updateFunc&&drawLoop())};export const update=updateFunction=>{"function"!=typeof updateFunction?console.error("The update function must take an argument as type 'function'."):null!==NOX_PV.updateFunc?console.warn("You already declared your update function."):(NOX_PV.updateFunc=updateFunction,"function"!=typeof NOX_PV.drawFunc&&drawLoop())};export class NoxCanvasModule{constructor(){if(this.constructor===NoxCanvasModule)throw new Error("[NoxCanvasModule] Object of Abstract Class cannot be created")}}export const addModule=module=>{if(!(module instanceof NoxCanvasModule))throw new Error("[addModule] given module does not extends NoxCanvasModule.");"function"==typeof module.update&&NOX_PV.updateModules.push(module),"function"==typeof module.render&&NOX_PV.renderingModules.push(module),NOX_PV.modules.push(module)};export const logPerformances=()=>{NOX_PV.logPerfs=!0};const NOX_PV={timer:new Time,hasInitGlobalHandlers:!1,updateFunc:()=>{},drawFunc:()=>{},modules:[],updateModules:[],renderingModules:[],logPerfs:!1,drawLoopInfo:{it:0,t0:0,t1:0,t2:0,freq:720},drawCond:()=>!0,camera:{hud:null,enabled:!0,move:null},cam:null,lut:[],bFill:!0,bStroke:!0,keys:{},isMouseDown:!1,oldMouseX:0,oldMouseY:0,isPointerLocked:!1,swipexDown:null,swipeyDown:null,autoResize:0,lastSwipe:null,bGuideLines:!1,fontSize:"12px",fontFamily:"Monospace",loop:!0,timer:0,now:0,then:Date.now(),firstThen:Date.now(),interval:1e3/fps,delta:0,counter:0,time_el:0,colorTreatment:(...oColor)=>{const n=oColor.length,color0=oColor[0];if(color0 instanceof CanvasGradient||color0 instanceof CanvasPattern)return color0;if(color0 instanceof HEX||color0 instanceof RGB||color0 instanceof HSL)return color0.toString();if(n>0&&n<5&&oColor.every(c=>"number"==typeof c)){let p="rgb",g=0,b=0,a=0;3!==n&&4!==n||(g=1,b=2),2!==n&&4!==n||(p+="a",a=n-1);let color=`${p}(${color0}, ${oColor[g]}, ${oColor[b]}`;return a>0&&(color+=`, ${oColor[a]}`),color+=")",color}if(1===n&&"string"==typeof color0){oColor=color0.replace(/\s/gi,"");const reg={hex:/^#([0-9a-z]{3}){1,2}$/i,rgb:/^rgba?\((\d{1,3},){2}\d{1,3}(,(0|1|(0?\.\d+)))?\)$/,hsl:/^hsl\(\d{1,3},\d{1,3}%,\d{1,3}%\)$/,hsla:/^hsla\(\d{1,3},\d{1,3}%,\d{1,3}%,(0|1|(0?.\d+))\)$/,name:/^\w{3,30}$/};for(const regex in reg)if(reg[regex].test(oColor))return oColor}return"#000"},perlin:{lod:10,unit:1,gradient:[],seed:[],generateSeed:()=>Array(255).fill(0).map((i,j)=>j).sort(()=>Math.random()-.5),get:(x,y,lod=NOX_PV.perlin.lod,seed=NOX_PV.perlin.seed)=>{x/=lod,y/=lod;const[x0,y0]=[floor(x),floor(y)],[dx,dy,ii,jj]=[x-x0,y-y0,255&x0,255&y0],stuv=[];for(let i=0;i<4;i++)try{const v=seed[(ii+i%2+seed[jj+floor(i/2)])%255]%NOX_PV.perlin.gradient.length;stuv.push(NOX_PV.perlin.gradient[v][0]*(dx-i%2)+NOX_PV.perlin.gradient[v][1]*(dy-floor(i/2)))}catch(e){stuv.push(0)}const[Cx,Cy]=[3*dx*dx-2*dx*dx*dx,3*dy*dy-2*dy*dy*dy],[Li1,Li2]=[stuv[0]+Cx*(stuv[1]-stuv[0]),stuv[2]+Cx*(stuv[3]-stuv[2])];return map(Li1+Cy*(Li2-Li1),-NOX_PV.perlin.unit,NOX_PV.perlin.unit,0,1)}},easeElastic:(type,t,b,c,d)=>{if(0===t)return b;if(1==(t/=d))return b+c;const p=.45*d,s=p/(c<0?4:2*PI*1.57),x=sin(2*PI*(t*d-s)/p);return"in"===type?-c*pow(2,10*--t)*x+b:"out"===type?c*pow(2,-10*t)*x+c+b:t<1?c*pow(2,10*--t)*x*-.5+b:c*pow(2,-10*--t)*x*.5+c+b},callbackListeners:{},callback:(event,e)=>{event in NOX_PV.callbackListeners&&NOX_PV.callbackListeners[event](e)}};NOX_PV.perlin.gradient=[[NOX_PV.perlin.unit,NOX_PV.perlin.unit],[-NOX_PV.perlin.unit,NOX_PV.perlin.unit],[NOX_PV.perlin.unit,-NOX_PV.perlin.unit],[-NOX_PV.perlin.unit,-NOX_PV.perlin.unit]];for(let i=0;i<256;i++)NOX_PV.lut[i]=(i<16?"0":"")+i.toString(16);NOX_PV.easeFuncMap={linear:easeLinear,quadIn:easeInQuad,quadOut:easeOutQuad,quadInOut:easeInOutQuad,sineIn:easeInSine,sineOut:easeOutSine,sineInOut:easeInOutSine,expoIn:easeInExpo,expoOut:easeOutExpo,expoInOut:easeInOutExpo,circIn:easeInCirc,circOut:easeOutCirc,circInOut:easeInOutCirc,cubicIn:easeInCubic,cubicOut:easeOutCubic,cubicInOut:easeInOutCubic,quartIn:easeInQuart,quartOut:easeOutQuart,quartInOut:easeInOutQuart,quintIn:easeInQuint,quintOut:easeOutQuint,quintInOut:easeInOutQuint,backIn:easeInBack,backOut:easeOutBack,backInOut:easeInOutBack,elasticIn:easeInElastic,elasticOut:easeOutElastic,elasticInOut:easeInOutElastic};const camera=new Camera;NOX_PV.camera.hud=new Camera,NOX_PV.cam=camera;const initializeAllEventHandlers=()=>{const t0=performance.now(),offset=elt=>{const rect=elt.getBoundingClientRect();return{top:rect.top+document.body.scrollTop,left:rect.left+document.body.scrollLeft}};if(canvas.addEventListener("pointerdown",e=>{canvas.setPointerCapture(e.pointerId),NOX_PV.isMouseDown=!0,dragPoint={x:e.clientX-offset(canvas).left,y:e.clientY-offset(canvas).top},callback("mousedown",e),canvas.addEventListener("pointerup",()=>{try{canvas.releasePointerCapture(e.pointerId)}catch(e){}dragPoint=null,NOX_PV.isMouseDown=!1,"function"==typeof mouseUp&&mouseUp(e)},{once:!0})}),canvas.addEventListener("pointermove",e=>{if(mouseX=e.clientX,mouseY=e.clientY,mouseDirection.x=e.movementX,mouseDirection.y=e.movementY,NOX_PV.isMouseDown){const xUp=e.clientX,yUp=e.clientY,xDiff=dragPoint.x-xUp,yDiff=dragPoint.y-yUp;let swipeDir;swipeDir=abs(xDiff)>abs(yDiff)?xDiff>0?"left":"right":yDiff>0?"up":"down",NOX_PV.lastSwipe=swipeDir,NOX_PV.callback("swipe",swipeDir),NOX_PV.callback("drag",e)}else NOX_PV.callback("mousemove",e)}),canvas.addEventListener("click",e=>NOX_PV.callback("click",e)),canvas.addEventListener("mouseenter",e=>NOX_PV.callback("mouseenter",e)),canvas.addEventListener("mouseleave",e=>NOX_PV.callback("mouseleave",e)),canvas.addEventListener("wheel",e=>NOX_PV.callback("wheel",e)),canvas.addEventListener("contextmenu",e=>NOX_PV.callback("contextmenu",e)),canvas.addEventListener("dblclick",e=>NOX_PV.callback("dblclick",e)),NOX_PV.hasInitGlobalHandlers)return;NOX_PV.hasInitGlobalHandlers=!0,window.addEventListener("keypress",e=>{NOX_PV.keys[e.code]=!0,NOX_PV.callback("keypress",e)}),window.addEventListener("keydown",e=>{NOX_PV.keys[e.code]=!0,NOX_PV.callback("keydown",e)}),window.addEventListener("keyup",e=>{NOX_PV.keys[e.code]=!1,NOX_PV.callback("keyup",e)}),window.addEventListener("resize",()=>{const newWidth=document.documentElement.clientWidth,newHeight=document.documentElement.clientHeight;clearTimeout(NOX_PV.resizeEndedCallback),NOX_PV.resizeEndedCallback=setTimeout(()=>{MIN_DOC_SIZE=min(newWidth,newHeight),NOX_PV.loop=!0,2===NOX_PV.autoResize&&setCanvasSize(newWidth,newHeight),NOX_PV.callback("resizeended",{width:newWidth,height:newHeight})},100),1===NOX_PV.autoResize&&setCanvasSize(newWidth,newHeight),NOX_PV.callback("resize",{width:newWidth,height:newHeight})}),window.addEventListener("blur",()=>NOX_PV.callback("blur")),window.addEventListener("focus",()=>NOX_PV.callback("focus")),window.addEventListener("online",e=>NOX_PV.callback("online",e)),window.addEventListener("offline",e=>NOX_PV.callback("offline",e));const t1=performance.now();if(NOX_PV.logPerfs){const perfData={initHandlers:{ms:t1-t0}};console.info("Performances while initializing the canvas environment :"),console.table(perfData)}};